package aprove.Framework.IntTRS.Nonterm.GeoNonTerm;

import aprove.DPFramework.BasicStructures.TRSFunctionApplication;
import aprove.DPFramework.BasicStructures.TRSTerm;
import aprove.DPFramework.IDPProblem.IGeneralizedRule;
import aprove.Framework.IntTRS.IRSwTProblem;

/**
 * The main class of the geometric non-termination analysis presented by Jan
 * Leike and Matthias Heizmann. (Source:
 * https://monteverdi.informatik.uni-freiburg.de/tomcat/Website/?ui=tool&tool=lasso_ranker)
 * <br/>
 * <br/>
 * This class generates the STEM X and LOOP parts of a given
 * {@link aprove.Framework.IntTRS.IRSwTProblem#IRSwTProblem(immutables.Immutable.ImmutableSet)
 * IRSwTProblem}, derives a speed matrix J as a column vector of generalized
 * eigenvalues and a direction matrix Y. <br/>
 * After the derivation of the linear program to the form X + Y * (sum_i_k) * 1
 * where k is the k-th iteration step the method uses a SMTSolver to derive a so
 * called Geometric Non-Termination Argument.
 * 
 * @author Timo Bergerbusch *
 */
public class GeoNonTermAnalysis {

	/**
	 * a Logger or Outputstream to print data into a file <br/>
	 * (Default: "/home/timo/Downloads/GeoNonTerm-ausgabe.txt")
	 */
	public static final Logger LOG = new Logger();
	
	/**
	 * the original IRSwTProblem, which is generated out of the LLVMGraph
	 * 
	 */
	private final IRSwTProblem problem;

	/**
	 * the STEM of the loop program
	 */
	private Stem stem;

	/**
	 * The constructor of the GeoNonTermAnalysis
	 * 
	 * @param problem
	 *            the reduced IRSwTProblem generated by the LLVMGraph
	 */
	public GeoNonTermAnalysis(IRSwTProblem problem) {
		this.problem = problem;
		this.deriveSTEM();
	}

	/**
	 * derives the STEM part of the {@link #problem IRSwTProblem} using the
	 * {@link aprove.Framework.IntTRS.IRSwTProblem#getStartTerm() startterm}
	 */
	private void deriveSTEM() {
		TRSFunctionApplication startterm = this.problem.getStartTerm();
		IGeneralizedRule[] rules = this.problem.getRules().toArray(new IGeneralizedRule[] {});

		LOG.writeln("Der Startterm ist: " + startterm.toString());

		for (int i = 0; i < rules.length; i++) {
			if (rules[i].getLeft().equals(startterm)) { 
				// Suchen der ersten passenden regel
				LOG.writeln("First rule match:" + rules[i].toString()); 

				TRSTerm r = rules[i].getRight();

				LOG.newLine();
				LOG.writeln("RHS Term: " + r.toString());
				LOG.writeln("FunctionSymbols: " + r.getFunctionSymbols().toString());
				LOG.writeln("Variables: " + r.getVariables());
				
				
				break; // danach kann abgebrochen werden
			} else if (i == rules.length - 1) { 
				// dieser Fall darf eigentlich nie eintreten
				LOG.writeln("No match found.");
			} else {
				// fÃ¼r den Fall, dass es nicht die STEM->LOOP rule ist
				LOG.writeln("Rule: "+ rules[i].toString());
				TRSTerm c = rules[i].getCondTerm();
				LOG.writeln("Cond Term: " +c.toString());
				LOG.writeln("FunctionSymbols: " + c.getFunctionSymbols().toString());
				LOG.writeln("Variables: " + c.getVariables());
			}
		}
		LOG.close();

	}

	/**
	 * derives the LOOP part of the {@link #problem IRSwTProblem} using the
	 * rules with respect to the guards
	 */
	private void deriveLOOP() {

	}

	/**
	 * computes the speed matrix J and direction matrix Y based on the LOOP
	 */
	private void computeSpeedAndDirectionMatrix() {

	}

}
