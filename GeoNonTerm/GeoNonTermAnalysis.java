package aprove.Framework.IntTRS.Nonterm.GeoNonTerm;

import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

import aprove.DPFramework.BasicStructures.Position;
import aprove.DPFramework.BasicStructures.TRSFunctionApplication;
import aprove.DPFramework.BasicStructures.TRSTerm;
import aprove.DPFramework.BasicStructures.TRSVariable;
import aprove.DPFramework.IDPProblem.IGeneralizedRule;
import aprove.Framework.BasicStructures.FunctionSymbol;
import aprove.Framework.IntTRS.IRSwTProblem;
import aprove.Framework.IntTRS.Nonterm.GeoNonTerm.ReversePolishNotationTree.*;
import aprove.Framework.Utility.GenericStructures.Pair;

/**
 * The main class of the geometric non-termination analysis presented by Jan
 * Leike and Matthias Heizmann. (Source:
 * https://monteverdi.informatik.uni-freiburg.de/tomcat/Website/?ui=tool&tool=lasso_ranker)
 * <br/>
 * <br/>
 * This class generates the STEM X and LOOP parts of a given
 * {@link aprove.Framework.IntTRS.IRSwTProblem#IRSwTProblem(immutables.Immutable.ImmutableSet)
 * IRSwTProblem}, derives a speed matrix J as a column vector of generalized
 * eigenvalues and a direction matrix Y. <br/>
 * After the derivation of the linear program to the form X + Y * (sum_i_k) * 1
 * where k is the k-th iteration step the method uses a SMTSolver to derive a so
 * called Geometric Non-Termination Argument.
 * 
 * @author Timo Bergerbusch *
 */
public class GeoNonTermAnalysis {

    /**
     * a Logger or Outputstream to print data into a file <br/>
     * (Default: "/home/timo/Downloads/GeoNonTerm-ausgabe.txt")
     */
    public static final Logger LOG = new Logger();

    /**
     * the original IRSwTProblem, which is generated out of the LLVMGraph
     * 
     */
    private final IRSwTProblem problem;

    /**
     * the rules of the problem. <br>
     * these are separately stored to derive {@link Stem} and {@link Loop}
     * separately without recomputing the rules.
     */
    private final IGeneralizedRule[] rules;

    /**
     * the STEM of the loop program
     */
    private Stem stem;

    /**
     * The constructor of the GeoNonTermAnalysis
     * 
     * @param problem
     *            the reduced IRSwTProblem generated by the LLVMGraph
     */
    public GeoNonTermAnalysis(IRSwTProblem problem) {
	this.problem = problem;
	rules = this.problem.getRules().toArray(new IGeneralizedRule[] {});
	this.deriveSTEM();
	this.deriveLOOP();

	LOG.close();
    }

    /**
     * derives the STEM part of the {@link #problem IRSwTProblem} using the
     * {@link aprove.Framework.IntTRS.IRSwTProblem#getStartTerm() startterm}
     */
    private void deriveSTEM() {
	TRSFunctionApplication startterm = this.problem.getStartTerm();

	LOG.writeln("Der Startterm ist: " + startterm.toString());

	for (int i = 0; i < rules.length; i++) {
	    if (rules[i].getLeft().equals(startterm)) {
		// Suchen der ersten passenden regel
		LOG.writeln("First rule match:" + rules[i].toString());

		TRSTerm r = rules[i].getRight();

		FunctionSymbol[] arr = new FunctionSymbol[r.getSize() - 1];
		arr = r.getFunctionSymbols().toArray(arr);
		stem = new Stem(arr);
		break; // danach kann abgebrochen werden
	    } else if (i == rules.length - 1) {
		// dieser Fall darf eigentlich nie eintreten
		LOG.writeln("No match found.");
	    }
	}

    }

    /**
     * derives the LOOP part of the {@link #problem IRSwTProblem} using the
     * rules with respect to the guards
     */
    private void deriveLOOP() {
	int index = this.getIndexOfSymbol(rules, stem.getStartFunctionSymbol());
	TRSFunctionApplication leftSide = rules[index].getLeft(); // is instance
								  // of
								  // TRSConstantTerm
	TRSTerm rightSide = rules[index].getRight(); // is instance of
						     // TRSCompoundTerm

	// Vergleichen des ersten FunctionSymbol der beiden Seiten
	if (leftSide.getFunctionSymbols().toArray(new FunctionSymbol[] {})[0]
		.equals(rightSide.getFunctionSymbols().toArray(new FunctionSymbol[] {})[0])) {
	    // die Regel hat die Form f_x -> f_x :|: cond

	    String[] occuringVars = this.deriveVariablesAsStringArray(leftSide.getVariables());

	    LOG.writeln("Investigating the rule " + rules[index]);
	    LOG.writeln("Rule " + index + " is of the Form: f_x -> f_x :|: cond");

	    LOG.writeln("+++++++++");
	    LOG.writeln("leftSide: " + leftSide.toString());
	    LOG.writeln("right: " + rightSide.toString());
	    LOG.writeln("Variables : " + occuringVars.toString());
	    LOG.writeln("++++++++++");

	    // Es wird versucht die rechte Seite in ein RPNTree zu parsen
	    RPNNode[] variableUpdates = new RPNNode[leftSide.getVariables().size()];
	    try {
		for (int i = 0; i < variableUpdates.length; i++)
		    variableUpdates[i] = RPNTreeParser.parseSetToTree(rightSide.getSubterm(Position.create(i)));
	    } catch (UnsupportetArithmeticSymbolException e) {
		e.printStackTrace();
		LOG.writeln("UnsupportetArithmeticSymbolException: " + e.getMessage());
	    } catch (ArrayIndexOutOfBoundsException e) {
		e.printStackTrace();
		LOG.writeln("ArrayIndexOutOfBoundsException: More Vars then Updates");
	    }

	    // LOG.printArray(variableUpdates);

	    UpdateMatrix m = new UpdateMatrix(occuringVars);
	    // LOG.printArray(m.getVarNames());
	    // m.setEntry("x3", "x8", 1);
	    // LOG.writeln("Does " + occuringVars[0] + " contain " +
	    // occuringVars[0] + "? "
	    // + variableUpdates[0].containsVar(occuringVars[0]));
	    // LOG.writeln("Does " + occuringVars[0] + " contain " +
	    // occuringVars[1] + "? "
	    // + variableUpdates[0].containsVar(occuringVars[1]));

	    for (int i = 0; i < occuringVars.length; i++) {
		for (int j = 0; j < occuringVars.length; j++) {
		    LOG.writeln("Does " + occuringVars[i] + " contain " + occuringVars[j] + "? "
			    + variableUpdates[i].containsVar(occuringVars[j]) + " \t Value:"
			    + variableUpdates[i].getFactorOfVar(occuringVars[j]));
		    m.setEntry(occuringVars[i], occuringVars[j], variableUpdates[i].getFactorOfVar(occuringVars[j]));
		}
	    }

	    LOG.writeln(m);

	    // LOG.writeln(rightSide.getSubterm(Position.create(0)).toString());
	} else {
	    // die Regel hat die Form f_x -> f_y :|: cond
	    LOG.writeln("Rule " + index + " is of the Form: f_x -> f_y :|: cond");
	}
    }

    /**
     * converts a {@link Set} of {@link TRSVariable TRSVariable's} into a
     * <code>String</code> array of the same size only storing their names given
     * by {@link TRSVariable}{@link #toString()}.
     * 
     * @param variables
     *            the Set of {@link TRSVariable TRSVariable's}
     * @return the <code>String</code> array of the variables names
     */
    private String[] deriveVariablesAsStringArray(Set<TRSVariable> variables) {
	String[] names = new String[variables.size()];
	Iterator<TRSVariable> iterator = variables.iterator();
	int i = 0;
	while (iterator.hasNext()) {
	    names[i] = iterator.next().toString();
	    i++;
	}

	return names;
    }

    /**
     * looks up the index of a {@link IGeneralizedRule} in an array that starts
     * with the given {@link FunctionSymbol}
     * 
     * @param rules
     *            the array of {@link IGeneralizedRule}'s
     * @param fs
     *            the query {@link FunctionSymbol}
     * @return den index ( -1 if isn't contained)
     */
    private int getIndexOfSymbol(IGeneralizedRule[] rules, FunctionSymbol fs) {
	int j = -1;
	for (int i = 0; i < this.rules.length; i++) {
	    if (rules[i].getLeft().getFunctionSymbol().equals(fs)) {
		j = i;
		LOG.writeln("##########");
		LOG.writeln(rules[i].getLeft().toString() + " matches " + fs.toString());
		LOG.writeln("So Rule Nr." + j + " starts with " + fs.toString());
		LOG.writeln("##########");
		break;
	    }
	}

	return j;
    }

}
