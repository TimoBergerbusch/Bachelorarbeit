package aprove.Framework.IntTRS.Nonterm.GeoNonTerm;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Set;
import java.util.Stack;

import org.sat4j.minisat.SolverFactory;

import aprove.DPFramework.BasicStructures.Position;
import aprove.DPFramework.BasicStructures.TRSCompoundTerm;
import aprove.DPFramework.BasicStructures.TRSFunctionApplication;
import aprove.DPFramework.BasicStructures.TRSTerm;
import aprove.DPFramework.BasicStructures.TRSVariable;
import aprove.DPFramework.IDPProblem.IGeneralizedRule;
import aprove.Framework.BasicStructures.FunctionSymbol;
import aprove.Framework.BasicStructures.Arithmetic.ArithmeticOperationType;
import aprove.Framework.BasicStructures.Arithmetic.Integer.FunctionalIntegerExpression;
import aprove.Framework.BasicStructures.Arithmetic.Integer.IntegerRelationType;
import aprove.Framework.BasicStructures.Arithmetic.Integer.PlainIntegerConstant;
import aprove.Framework.BasicStructures.Arithmetic.Integer.PlainIntegerOperation;
import aprove.Framework.BasicStructures.Arithmetic.Integer.PlainIntegerRelation;
import aprove.Framework.BasicStructures.Arithmetic.Integer.PlainIntegerVariable;
import aprove.Framework.IntTRS.IRSwTProblem;
import aprove.Framework.IntTRS.Nonterm.GeoNonTerm.ReversePolishNotationTree.RPNNode;
import aprove.Framework.IntTRS.Nonterm.GeoNonTerm.ReversePolishNotationTree.RPNTreeParser;
import aprove.Framework.IntTRS.Nonterm.GeoNonTerm.ReversePolishNotationTree.UnsupportetArithmeticSymbolException;
import aprove.Framework.Logic.YNM;
import aprove.Framework.SMT.SMTLIBLogic;
import aprove.Framework.SMT.Expressions.StaticBuilders.Ints;
import aprove.Framework.SMT.Solver.Factories.Z3ExtSolverFactory;
import aprove.Framework.SMT.Solver.Z3.Z3Solver;
import aprove.Framework.SMT.Solver.Z3.Z3SolverFactory;
import aprove.Strategies.Abortions.AbortionFactory;

/**
 * The main class of the geometric non-termination analysis presented by Jan
 * Leike and Matthias Heizmann. (Source:
 * https://monteverdi.informatik.uni-freiburg.de/tomcat/Website/?ui=tool&tool=lasso_ranker)
 * <br/>
 * <br/>
 * This class generates the STEM X and LOOP parts of a given
 * {@link aprove.Framework.IntTRS.IRSwTProblem#IRSwTProblem(immutables.Immutable.ImmutableSet)
 * IRSwTProblem}, derives a speed matrix J as a column vector of generalized
 * eigenvalues and a direction matrix Y. <br/>
 * After the derivation of the iteration matrix A and constants b, so that A*(x
 * x') <= b , the method uses a SMTSolver to derive a so called Geometric
 * Non-Termination Argument.
 * 
 * @author Timo Bergerbusch *
 */
public class GeoNonTermAnalysis {

    /**
     * converts a {@link Set} of {@link TRSVariable TRSVariable's} into a
     * <code>String</code> array of the same size only storing their names given
     * by {@link TRSVariable}{@link #toString()}.
     * 
     * @param variables
     *            the Set of {@link TRSVariable TRSVariable's}
     * @return the <code>String</code> array of the variables names
     */
    private static String[] deriveVariablesAsStringArray(Set<TRSVariable> variables) {
	String[] names = new String[variables.size()];
	Iterator<TRSVariable> iterator = variables.iterator();
	int i = 0;
	while (iterator.hasNext()) {
	    names[i] = iterator.next().toString();
	    i++;
	}

	return names;
    }

    /**
     * a static boolean to determine if the information about the process should
     * be printed using the {@link Logger#getLog() Logger}.
     */
    private static boolean SHOULD_PRINT = false;

    /**
     * the original IRSwTProblem, which is generated out of the LLVMGraph
     * 
     */
    private IRSwTProblem problem;

    /**
     * the rules of the problem. <br>
     * these are separately stored to derive {@link Stem} and {@link Loop}
     * separately without recomputing the rules.
     */
    private IGeneralizedRule[] rules;

    /**
     * the STEM of the loop program
     */
    private Stem stem;

    /**
     * the LOOP of the loop program
     */
    private Loop loop;

    /**
     * The constructor of the GeoNonTermAnalysis
     * 
     * @param problem
     *            the reduced IRSwTProblem generated by the LLVMGraph
     */
    public GeoNonTermAnalysis(IRSwTProblem problem) {
	this.problem = problem;
	rules = this.problem.getRules().toArray(new IGeneralizedRule[] {});

	if (this.problem.getStartTerm() != null) {
	    this.deriveSTEM();
	    this.deriveLOOP();

	    GeoNonTermArgument gna = this.tryDerivingAGNA();
	    Logger.getLog()
		    .writeln("GNA-Test: " + gna.validate(loop.getIterationMatrix(), loop.getIterationConstants()));
	}

	Logger.getLog().close();
    }

    /**
     * derives the STEM part of the {@link #problem IRSwTProblem} using the
     * {@link aprove.Framework.IntTRS.IRSwTProblem#getStartTerm() startterm}
     */
    private void deriveSTEM() {
	TRSFunctionApplication startterm = this.problem.getStartTerm();

	if (SHOULD_PRINT)
	    if (startterm != null)
		Logger.getLog().writeln("Der Startterm ist: " + startterm.toString());
	    else
		Logger.getLog().writeln("Das IRS hat keinen Startterm.");

	if (startterm == null) {
	    // TODO: wenn es keinen Startterm gibt muss eine Belegung gefunden
	    // werden, sodass eine Regel anwendbar ist.
	} else
	    for (int i = 0; i < rules.length; i++) {
		if (rules[i].getLeft().equals(startterm)) {
		    // Suchen der ersten passenden regel
		    if (SHOULD_PRINT)
			Logger.getLog().writeln("First rule match:" + rules[i].toString());

		    stem = new Stem(this.getRuleAsArray(rules[i]));
		    break; // danach kann abgebrochen werden
		} else if (i == rules.length - 1) {
		    // dieser Fall darf eigentlich nie eintreten
		    Logger.getLog().writeln("ERROR: No match found for startterm.");
		}
	    }

    }

    private FunctionSymbol[] getRuleAsArray(IGeneralizedRule rule) {
	// TODO: Wenn links und rechts nicht die selben VAR's haben
	TRSTerm r = rule.getRight();
	FunctionSymbol[] arr = new FunctionSymbol[r.getSize() - 1];
	arr = r.getFunctionSymbols().toArray(arr);
	return arr;
    }

    /**
     * computes the {@link Loop} by computing the updateMatrix and
     * updateConstants of the {@link Loop} using
     * {@link #deriveUpdatePart(TRSTerm, TRSTerm)} and afterwards computing the
     * guardMatrix with corresponding guardConstants using
     * {@link #deriveGuardPart(IGeneralizedRule)}.
     * 
     * @see GeoNonTermAnalysis#deriveUpdatePart(TRSTerm, TRSTerm)
     * @see #deriveGuardPart(IGeneralizedRule)
     * @see Loop
     */
    private void deriveLOOP() {
	this.loop = new Loop();

	int index = this.getIndexOfSymbol(rules, stem.getStartFunctionSymbol());
	TRSFunctionApplication leftSide = rules[index].getLeft();
	TRSTerm rightSide = rules[index].getRight();

	// Vergleichen des ersten FunctionSymbol der beiden Seiten
	if (leftSide.getFunctionSymbols().toArray(new FunctionSymbol[] {})[0]
		.equals(rightSide.getFunctionSymbols().toArray(new FunctionSymbol[] {})[0])) {
	    // die Regel hat die Form f_x -> f_x :|: cond
	    if (SHOULD_PRINT) {
		Logger.getLog().writeln("Investigating the rule " + rules[index]);
		Logger.getLog().writeln("Rule " + index + " is of the Form: f_x -> f_x :|: cond");
	    }

	    // loop.setDimensions(leftSide.getVariables().size(),
	    // rules[index].getCondTerm().toString().split("&&").length);

	    // Suche aus dem rechten Teil die Updates raus
	    this.deriveUpdatePart(leftSide, rightSide);

	    // suche aus den conditions the Regeln raus
	    this.deriveGuardPart(rules[index]);

	    loop.computeIterationMatrixAndConstants();

	    if (SHOULD_PRINT) {
		Logger.getLog().writeln(Loop.getSystemAsString(loop.getIterationMatrix(),
			new String[] { "x0_0", "x0_1", "x1_0", "x1_1" }, loop.getIterationConstants()));
	    }
	    // Logger.getLog().writeln(rightSide.getSubterm(Position.create(0)).toString());
	} else {
	    // die Regel hat die Form f_x -> f_y :|: cond
	    if (SHOULD_PRINT)
		Logger.getLog().writeln("Rule " + index + " is of the Form: f_x -> f_y :|: cond");
	}
    }

    /**
     * This method derives the update matrix and constants to a given rule, by
     * parsing it into a {@link RPNNode RPNTree} using
     * {@link RPNTreeParser#parseSetToTree(TRSTerm)}. Note: it gets left and
     * right instead of the rule itself, because they are already computed
     * anyway.
     * 
     * @param leftSide
     *            the left side the rule
     * @param rightSide
     *            the right side of the rule.
     */
    private void deriveUpdatePart(TRSTerm leftSide, TRSTerm rightSide) {
	String[] occuringVars = GeoNonTermAnalysis.deriveVariablesAsStringArray(leftSide.getVariables());

	// Es wird versucht die rechte Seite in ein RPNTree zu parsen
	RPNNode[] variableUpdates = new RPNNode[leftSide.getVariables().size()];
	try {
	    for (int i = 0; i < variableUpdates.length; i++)
		variableUpdates[i] = RPNTreeParser.parseSetToTree(rightSide.getSubterm(Position.create(i)));
	} catch (UnsupportetArithmeticSymbolException e) {
	    e.printStackTrace();
	    Logger.getLog().writeln("UnsupportetArithmeticSymbolException: " + e.getMessage());
	} catch (ArrayIndexOutOfBoundsException e) {
	    e.printStackTrace();
	    Logger.getLog().writeln("ArrayIndexOutOfBoundsException: More Vars then Updates");
	}
	GNAMatrix updateMatrix = new GNAMatrix(occuringVars);
	GNAVector updateConstants = new GNAVector(occuringVars.length, 0);

	// Herleiten der Update-Matrix EintrÃ¤ge
	for (int i = 0; i < occuringVars.length; i++) {
	    for (int j = 0; j < occuringVars.length; j++) {
		// Logger.getLog().writeln("Does " + occuringVars[i] + " contain
		// " +
		// occuringVars[j] + "? "
		// + variableUpdates[i].containsVar(occuringVars[j]) + " \t
		// Value:"
		// + variableUpdates[i].getFactorOfVar(occuringVars[j]));
		updateMatrix.setEntry(occuringVars[i], occuringVars[j],
			variableUpdates[i].getFactorOfVar(occuringVars[j]));
	    }
	    // Logger.getLog().writeln("Does Update of Var. " + i + " contain a
	    // Constant
	    // term? Term: "
	    // + variableUpdates[i].getConstantTerm());
	    updateConstants.set(i, variableUpdates[i].getConstantTerm());
	}

	// Logger.getLog().writeln(updateMatrix);
	loop.setUpdateMatrix(updateMatrix);
	loop.setUpdateConstants(updateConstants);
    }

    /**
     * This method derives the guard matrix and constants of a given rule, by
     * parsing only the condition terms into a {@link RPNNode RPNTree} after
     * splitting them into the different rules. <br>
     * So it splits: <code>x_1 > 0 && x_3 > 5</code><br>
     * Into the two conditions and parses them separately.
     * 
     * @param rule
     *            the rule containing the conditions
     */
    private void deriveGuardPart(IGeneralizedRule rule) {
	// Logger.getLog().writeln("++++++++++");
	// Logger.getLog().writeln("Cond Term: " + rule.getCondTerm());
	// Logger.getLog().writeln("Cond Vars" + rule.getCondVariables());

	ArrayList<TRSTerm> condTerms = new ArrayList<>();
	Stack<TRSTerm> stack = new Stack<>();
	stack.push(rule.getCondTerm());

	TRSTerm curr;
	while (!stack.isEmpty()) {
	    curr = stack.pop();
	    // Logger.getLog().writeln("investigating: " + curr.toString());
	    if (curr instanceof TRSCompoundTerm) {
		if (((TRSCompoundTerm) curr).getFunctionSymbol().toString().equals("&&_2")) {
		    stack.push(((TRSCompoundTerm) curr).getArgument(0));
		    stack.push(((TRSCompoundTerm) curr).getArgument(1));
		    // Logger.getLog().writeln("TRSCompoundTerm");
		} else {
		    condTerms.add(curr);
		    // Logger.getLog().writeln("Not TRSCompoundTerm");
		}
	    }
	}

	ArrayList<TRSTerm> condTermsReverse = new ArrayList<>();
	for (int i = condTerms.size() - 1; i >= 0; i--) {
	    condTermsReverse.add(condTerms.get(i));
	}
	condTerms = condTermsReverse;

	// Die GuardMatrix fÃ¼r die versch. Bedingungen
	GNAMatrix guardMatrix = new GNAMatrix(condTerms.size(), rule.getLeft().getVariables().size(),
		GeoNonTermAnalysis.deriveVariablesAsStringArray(rule.getLeft().getVariables()));
	// Die Constanten, welche erfÃ¼llt werden mÃ¼ssen
	GNAVector guardConstants = new GNAVector(condTerms.size(), 0);

	// Logger.getLog().writeln("Cond Terms: " + condTerms);
	for (int i = 0; i < condTerms.size(); i++)
	    try {
		RPNNode root = RPNTreeParser.parseSetToTree(condTerms.get(i));
		if (SHOULD_PRINT)
		    Logger.getLog().writeln("ÃberprÃ¼fe: " + root.toString());
		for (TRSVariable var : condTerms.get(i).getVariables()) {
		    if (root.containsVar(var.toString())) {
			if (SHOULD_PRINT)
			    Logger.getLog().writeln("-> beinhaltet " + var.toString() + " mit dem Factor: "
				    + root.getFactorOfVar(var.toString()));
			guardMatrix.setEntry(i, var.toString(), root.getFactorOfVar(var.toString()));
		    }
		}
		guardConstants.set(i, root.getConstantTerm());
	    } catch (UnsupportetArithmeticSymbolException e) {
		e.printStackTrace();
	    }
	// alle > in < umdrehen, sodass die constante immer < da steht:
	// ... < c
	// UpdateMatrix.negateMatrix(guardMatrix);
	guardMatrix.negate();
	for (int i = 0; i < guardConstants.size(); i++)
	    guardConstants.set(i, guardConstants.get(i) * -1 - 1);

	loop.setGuardUpdates(guardMatrix);
	loop.setGuardConstants(guardConstants);

	// Logger.getLog().writeln(guardMatrix);
	// Logger.getLog().writeln(guardConstants);
	// Logger.getLog().writeln("++++++++++");
    }

    private GeoNonTermArgument tryDerivingAGNA() {
	int[] eigenvalues = loop.getUpdateMatrix().computeEigenvalues();

	// +++++++++++++++++++++++++++++++++++++++++++++
	Z3ExtSolverFactory factory = new Z3ExtSolverFactory();
	Z3Solver solver = factory.getSMTSolver(SMTLIBLogic.QF_NIA, AbortionFactory.create());
	SMTFactory smt = new SMTFactory();
	// ArrayList<PlainIntegerRelation> relations = new ArrayList<>();
	// relations.add(new PlainIntegerRelation(IntegerRelationType.LE,
	// smt.createVar("x"), smt.createConst(10)));
	// relations.add(new PlainIntegerRelation(IntegerRelationType.GE,
	// smt.createVar("x"),
	// new PlainIntegerOperation(ArithmeticOperationType.ADD,
	// smt.createConst(5), smt.createConst(2))));
	//
	// for (PlainIntegerRelation pir : relations)
	// solver.addAssertion(pir.toSMTExp());
	// Logger.getLog().writeln("TEST: " + solver.checkSAT().toString());
	// Logger.getLog().writeln("TEST: " + solver.getModel().toString());
	// +++++++++++++++++++++++++++++++++++++++++++++

	// Das berechnen vom Point Kriterium
	GNAVariableVector varVec = new GNAVariableVector(new String[] { "10", "2", "10+s1", "2+s2" });
	RPNNode[] nodes = loop.getIterationMatrix().mult(varVec);
	FunctionalIntegerExpression exp;
	for (int i = 0; i < nodes.length; i++) {
	    exp = smt.parseRPNTreeToSMTRule(nodes[i]);

	    solver.addAssertion(
		    smt.createRule(IntegerRelationType.LE, exp, smt.createConst(loop.getIterationConstants().get(i)))
			    .toSMTExp());
	}

	GNAVariableVector pointCritVec1 = new GNAVariableVector(new String[] { "a", "b", "3*a", "3*b" });
	RPNNode[] nodesCrit1 = loop.getIterationMatrix().mult(pointCritVec1);
	FunctionalIntegerExpression expCrit1;
	for (int i = 0; i < nodesCrit1.length; i++) {
	    expCrit1 = smt.parseRPNTreeToSMTRule(nodesCrit1[i]);

	    solver.addAssertion(smt.createRule(IntegerRelationType.LE, expCrit1, smt.createConst(0)).toSMTExp());
	}

	GNAVariableVector pointCritVec2 = new GNAVariableVector(new String[] { "c", "d", "2*c+x*a", "2*d+x*b" });
	RPNNode[] nodesCrit2 = loop.getIterationMatrix().mult(pointCritVec2);
	FunctionalIntegerExpression expCrit2;
	for (int i = 0; i < nodesCrit2.length; i++) {
	    expCrit2 = smt.parseRPNTreeToSMTRule(nodesCrit2[i]);

	    solver.addAssertion(smt.createRule(IntegerRelationType.LE, expCrit2, smt.createConst(0)).toSMTExp());
	}

	solver.addAssertion(smt.createRule(IntegerRelationType.EQ,
		smt.createOperation(ArithmeticOperationType.ADD, smt.createVar("a"), smt.createVar("c")),
		smt.createVar("s1")).toSMTExp());
	solver.addAssertion(smt.createRule(IntegerRelationType.EQ,
		smt.createOperation(ArithmeticOperationType.ADD, smt.createVar("b"), smt.createVar("d")),
		smt.createVar("s2")).toSMTExp());

	Logger.getLog().writeln("SAT: " + solver.checkSAT().toString());
	if (solver.checkSAT() == YNM.YES)
	    Logger.getLog().writeln("MODEl: " + solver.getModel().toString());

	// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	GeoNonTermArgument gna = new GeoNonTermArgument(stem,
		new GNAVector[] { new GNAVector(new int[] { 8, 0 }), new GNAVector(new int[] { 14, 2 }) }, eigenvalues,
		new int[] { 2 });

	return gna;
    }

    /**
     * looks up the index of a {@link IGeneralizedRule} in an array that starts
     * with the given {@link FunctionSymbol}
     * 
     * @param rules
     *            the array of {@link IGeneralizedRule}'s
     * @param fs
     *            the query {@link FunctionSymbol}
     * @return den index ( -1 if isn't contained)
     */
    private int getIndexOfSymbol(IGeneralizedRule[] rules, FunctionSymbol fs) {
	int j = -1;
	for (int i = 0; i < this.rules.length; i++) {
	    if (rules[i].getLeft().getFunctionSymbol().equals(fs)) {
		j = i;
		if (SHOULD_PRINT) {
		    Logger.getLog().writeln("##########");
		    Logger.getLog().writeln(rules[i].getLeft().toString() + " matches " + fs.toString());
		    Logger.getLog().writeln("So Rule Nr." + j + " starts with " + fs.toString());
		    Logger.getLog().writeln("##########");
		}
		break;
	    }
	}

	return j;
    }

}
