package aprove.Framework.IntTRS.Nonterm.GeoNonTerm;

import java.util.Collection;

import aprove.DPFramework.BasicStructures.Position;
import aprove.DPFramework.BasicStructures.TRSFunctionApplication;
import aprove.DPFramework.BasicStructures.TRSTerm;
import aprove.DPFramework.IDPProblem.IGeneralizedRule;
import aprove.Framework.BasicStructures.FunctionSymbol;
import aprove.Framework.IntTRS.IRSwTProblem;
import aprove.Framework.IntTRS.Nonterm.GeoNonTerm.ReversePolishNotationTree.*;
import aprove.Framework.Utility.GenericStructures.Pair;

/**
 * The main class of the geometric non-termination analysis presented by Jan
 * Leike and Matthias Heizmann. (Source:
 * https://monteverdi.informatik.uni-freiburg.de/tomcat/Website/?ui=tool&tool=lasso_ranker)
 * <br/>
 * <br/>
 * This class generates the STEM X and LOOP parts of a given
 * {@link aprove.Framework.IntTRS.IRSwTProblem#IRSwTProblem(immutables.Immutable.ImmutableSet)
 * IRSwTProblem}, derives a speed matrix J as a column vector of generalized
 * eigenvalues and a direction matrix Y. <br/>
 * After the derivation of the linear program to the form X + Y * (sum_i_k) * 1
 * where k is the k-th iteration step the method uses a SMTSolver to derive a so
 * called Geometric Non-Termination Argument.
 * 
 * @author Timo Bergerbusch *
 */
public class GeoNonTermAnalysis {

	/**
	 * a Logger or Outputstream to print data into a file <br/>
	 * (Default: "/home/timo/Downloads/GeoNonTerm-ausgabe.txt")
	 */
	public static final Logger LOG = new Logger();

	/**
	 * the original IRSwTProblem, which is generated out of the LLVMGraph
	 * 
	 */
	private final IRSwTProblem problem;

	/**
	 * the rules of the problem. <br>
	 * these are separately stored to derive {@link Stem} and {@link Loop}
	 * separately without recomputing the rules.
	 */
	private final IGeneralizedRule[] rules;

	/**
	 * the STEM of the loop program
	 */
	private Stem stem;

	/**
	 * The constructor of the GeoNonTermAnalysis
	 * 
	 * @param problem
	 *            the reduced IRSwTProblem generated by the LLVMGraph
	 */
	public GeoNonTermAnalysis(IRSwTProblem problem) {
		this.problem = problem;
		rules = this.problem.getRules().toArray(new IGeneralizedRule[] {});
		this.deriveSTEM();
		this.deriveLOOP();

		LOG.close();
	}

	/**
	 * derives the STEM part of the {@link #problem IRSwTProblem} using the
	 * {@link aprove.Framework.IntTRS.IRSwTProblem#getStartTerm() startterm}
	 */
	private void deriveSTEM() {
		TRSFunctionApplication startterm = this.problem.getStartTerm();

		LOG.writeln("Der Startterm ist: " + startterm.toString());

		for (int i = 0; i < rules.length; i++) {
			if (rules[i].getLeft().equals(startterm)) {
				// Suchen der ersten passenden regel
				LOG.writeln("First rule match:" + rules[i].toString());

				TRSTerm r = rules[i].getRight();

				FunctionSymbol[] arr = new FunctionSymbol[r.getSize() - 1];
				arr = r.getFunctionSymbols().toArray(arr);
				stem = new Stem(arr);
				break; // danach kann abgebrochen werden
			} else if (i == rules.length - 1) {
				// dieser Fall darf eigentlich nie eintreten
				LOG.writeln("No match found.");
			}
		}

	}

	/**
	 * derives the LOOP part of the {@link #problem IRSwTProblem} using the
	 * rules with respect to the guards
	 */
	private void deriveLOOP() {
		int index = this.getIndexOfSymbol(rules, stem.getStartFunctionSymbol());
		TRSFunctionApplication leftSide = rules[index].getLeft(); // is instance
																	// of
																	// TRSConstantTerm
		TRSTerm rightSide = rules[index].getRight(); // is instance of
														// TRSCompoundTerm

		// Vergleichen des ersten FunctionSymbol der beiden Seiten
		if (leftSide.getFunctionSymbols().toArray(new FunctionSymbol[] {})[0]
				.equals(rightSide.getFunctionSymbols().toArray(new FunctionSymbol[] {})[0])) {
			// die Regel hat die Form f_x -> f_x :|: cond
			LOG.writeln("Investigating the rule " + rules[index]);
			LOG.writeln("Rule " + index + " is of the Form: f_x -> f_x :|: cond");

			LOG.writeln("+++++++++");
			LOG.writeln("leftSide: " + leftSide.toString());
			LOG.writeln("right: " + rightSide.toString());
			LOG.writeln("Variables : " + leftSide.getVariables().toString());
			LOG.writeln("++++++++++");

			// Es wird versucht die rechte Seite in ein RPNTree zu parsen
			RPNTreeParser tp = new RPNTreeParser();
			RPNNode[] variableUpdates = new RPNNode[leftSide.getVariables().size()];
			try {
				for (int i = 0; i < variableUpdates.length; i++)
					variableUpdates[i] = tp.parseSetToTree(rightSide.getSubterm(Position.create(i)));
			} catch (UnsupportetArithmeticSymbolException e) {
				e.printStackTrace();
				LOG.writeln("UnsupportetArithmeticSymbolException: " + e.getMessage());
			} catch (ArrayIndexOutOfBoundsException e) {
				e.printStackTrace();
				LOG.writeln("ArrayIndexOutOfBoundsException: More Vars then Updates");
			}

			LOG.printArray(variableUpdates);
			
			// LOG.writeln(rightSide.getSubterm(Position.create(0)).toString());
		} else {
			// die Regel hat die Form f_x -> f_y :|: cond
			LOG.writeln("Rule " + index + " is of the Form: f_x -> f_y :|: cond");
		}
	}

	/**
	 * computes the speed matrix J and direction matrix Y based on the LOOP
	 */
	private void computeSpeedAndDirectionMatrix() {

	}

	/**
	 * looks up the index of a {@link IGeneralizedRule} in an array that starts
	 * with the given {@link FunctionSymbol}
	 * 
	 * @param rules
	 *            the array of {@link IGeneralizedRule}'s
	 * @param fs
	 *            the query {@link FunctionSymbol}
	 * @return den index ( -1 if isn't contained)
	 */
	private int getIndexOfSymbol(IGeneralizedRule[] rules, FunctionSymbol fs) {
		int j = -1;
		for (int i = 0; i < this.rules.length; i++) {
			if (rules[i].getLeft().getFunctionSymbol().equals(fs)) {
				j = i;
				LOG.writeln("##########");
				LOG.writeln(rules[i].getLeft().toString() + " matches " + fs.toString());
				LOG.writeln("So Rule Nr." + j + " starts with " + fs.toString());
				LOG.writeln("##########");
				break;
			}
		}

		return j;
	}

}
