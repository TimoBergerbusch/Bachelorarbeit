package aprove.Framework.IntTRS.Nonterm.GeoNonTerm;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;

import aprove.DPFramework.BasicStructures.Position;
import aprove.DPFramework.BasicStructures.TRSCompoundTerm;
import aprove.DPFramework.BasicStructures.TRSFunctionApplication;
import aprove.DPFramework.BasicStructures.TRSTerm;
import aprove.DPFramework.BasicStructures.TRSVariable;
import aprove.DPFramework.IDPProblem.IGeneralizedRule;
import aprove.Framework.BasicStructures.FunctionSymbol;
import aprove.Framework.BasicStructures.Arithmetic.Integer.FunctionalIntegerExpression;
import aprove.Framework.BasicStructures.Arithmetic.Integer.IntegerRelationType;
import aprove.Framework.BasicStructures.Arithmetic.Integer.PlainIntegerRelation;
import aprove.Framework.IntTRS.IRSwTProblem;
import aprove.Framework.IntTRS.Nonterm.GeoNonTerm.ReversePolishNotationTree.RPNNode;
import aprove.Framework.IntTRS.Nonterm.GeoNonTerm.ReversePolishNotationTree.RPNTreeParser;
import aprove.Framework.IntTRS.Nonterm.GeoNonTerm.ReversePolishNotationTree.UnsupportetArithmeticSymbolException;
import aprove.Framework.Logic.YNM;
import aprove.Framework.SMT.Expressions.SMTExpression;
import aprove.Framework.SMT.Expressions.Sorts.SBool;
import aprove.Framework.SMT.Expressions.Symbols.Symbol;
import aprove.Framework.SMT.Solver.SMTLIB.FunctionDefinition;
import aprove.Framework.SMT.Solver.SMTLIB.Model;
import aprove.Framework.SMT.Solver.Z3.Z3Solver;
import aprove.Framework.Utility.GenericStructures.Pair;

/**
 * The main class of the geometric non-termination analysis presented by Jan
 * Leike and Matthias Heizmann. (Source:
 * https://monteverdi.informatik.uni-freiburg.de/tomcat/Website/?ui=tool&tool=lasso_ranker)
 * <br/>
 * <br/>
 * This class generates the STEM X and LOOP parts of a given
 * {@link aprove.Framework.IntTRS.IRSwTProblem#IRSwTProblem(immutables.Immutable.ImmutableSet)
 * IRSwTProblem}, derives a speed matrix J as a column vector of generalized
 * eigenvalues and a direction matrix Y. <br/>
 * After the derivation of the iteration matrix A and constants b, so that A*(x
 * x') <= b , the method uses a SMTSolver to derive a so called Geometric
 * Non-Termination Argument.
 * 
 * @author Timo Bergerbusch *
 */
public class GeoNonTermAnalysis {

    /**
     * converts a {@link Set} of {@link TRSVariable TRSVariable's} into a
     * <code>String</code> array of the same size only storing their names given
     * by {@link TRSVariable}{@link #toString()}.
     * 
     * @param variables
     *            the Set of {@link TRSVariable TRSVariable's}
     * @return the <code>String</code> array of the variables names
     */
    private static String[] deriveVariablesAsStringArray(Set<TRSVariable> variables) {
	String[] names = new String[variables.size()];
	Iterator<TRSVariable> iterator = variables.iterator();
	int i = 0;
	while (iterator.hasNext()) {
	    names[i] = iterator.next().toString();
	    i++;
	}

	return names;
    }

    /**
     * a static boolean to determine if the information about the process should
     * be printed using the {@link Logger#getLog() Logger}.
     */
    private static boolean SHOULD_PRINT = false;

    /**
     * the original IRSwTProblem, which is generated out of the LLVMGraph
     * 
     */
    private IRSwTProblem problem;

    /**
     * the rules of the problem. <br>
     * these are separately stored to derive {@link Stem} and {@link Loop}
     * separately without recomputing the rules.
     */
    private IGeneralizedRule[] rules;

    /**
     * the STEM of the loop program
     */
    private Stem stem;

    /**
     * the LOOP of the loop program
     */
    private Loop loop;

    /**
     * a {@link SMTFactory} to create the SMT-Problem, which results in a
     * {@link GeoNonTermArgument} if one exists.
     */
    private SMTFactory smt = new SMTFactory();

    /**
     * an already derived {@link GeoNonTermAnalysis} to safe, so that we would
     * not compute it a second time.
     */
    private GeoNonTermArgument gna;

    /**
     * The constructor of the GeoNonTermAnalysis
     * 
     * @param problem
     *            the reduced IRSwTProblem generated by the LLVMGraph
     */
    public GeoNonTermAnalysis(IRSwTProblem problem) {
	this.problem = problem;
	rules = this.problem.getRules().toArray(new IGeneralizedRule[] {});

	// Logger.getLog().writeln(problem.toString());

	if (this.problem.getStartTerm() != null) {
	    this.deriveSTEM();
	    // Logger.getLog().writeln(stem);
	    this.deriveLOOP();

	    Logger.getLog().close();

	    GeoNonTermArgument gna = this.tryDerivingAGNA();
	    Logger.getLog()
		    .writeln("GNA-Test: " + gna.validate(loop.getIterationMatrix(), loop.getIterationConstants()));
	}

	Logger.getLog().close();
    }

    /**
     * Derives the STEM part of the {@link #problem IRSwTProblem} using the
     * {@link aprove.Framework.IntTRS.IRSwTProblem#getStartTerm() startterm}
     */
    private void deriveSTEM() {
	TRSFunctionApplication startterm = this.problem.getStartTerm();

	if (SHOULD_PRINT)
	    if (startterm != null)
		Logger.getLog().writeln("Der Startterm ist: " + startterm.toString());
	    else
		Logger.getLog().writeln("Das IRS hat keinen Startterm.");

	if (startterm == null) {
	    // TODO: wenn es keinen Startterm gibt muss eine Belegung gefunden
	    // werden, sodass eine Regel anwendbar ist.
	} else
	    for (int i = 0; i < rules.length; i++) {
		if (rules[i].getLeft().equals(startterm)) {
		    // Suchen der ersten passenden regel
		    if (SHOULD_PRINT)
			Logger.getLog().writeln("First rule match:" + rules[i].toString());

		    stem = new Stem(this.getRuleAsArray(rules[i]));
		    break; // danach kann abgebrochen werden
		} else if (i == rules.length - 1) {
		    // dieser Fall darf eigentlich nie eintreten
		    Logger.getLog().writeln("ERROR: No match found for startterm.");
		}
	    }

    }

    /**
     * This method takes in a rule and returns the variables that are mentioned
     * in the <u>right</u> side of the rule. Therefore it does not hold for
     * rule's that have different var's within a rule.
     * 
     * @param rule
     *            the rule to extract the variables from
     * @return the extracted variables
     */
    private FunctionSymbol[] getRuleAsArray(IGeneralizedRule rule) {
	// TODO: Wenn links und rechts nicht die selben VAR's haben

	assert ((TRSFunctionApplication) rule.getLeft()).getArity() == 0;

	TRSFunctionApplication r = (TRSFunctionApplication) rule.getRight();
	FunctionSymbol[] arr = new FunctionSymbol[r.getArity() + 1];
	arr[0] = r.getFunctionSymbol();

	if (r.getVariables().size() == 0) {
	    for (int i = 0; i < r.getArity(); i++) {
		TRSTerm arg = r.getArgument(i);
		arr[i + 1] = ((TRSFunctionApplication) arg).getFunctionSymbol();
	    }
	} else {

	    // Try deriving a sat. assignment for the STEM
	    try {
		Pair<GNAMatrix, GNAVector> pair = this.computeConditionMatrixAndConstants(rule);
		GNAVariableVector vec = new GNAVariableVector(pair.getKey().getVarNames());

		Z3Solver solver = smt.getSolver();

		pair.getKey().negate();
		for (int i = 0; i < pair.getValue().size(); i++)
		    pair.getValue().set(i, pair.getValue().get(i) * -1 - 1);

		smt.addAssertion(pair.getKey(), vec, pair.getValue());

		for (int i = 0; i < r.getArity(); i++) {

		    PlainIntegerRelation condRule = smt.createRule(IntegerRelationType.EQ, smt.createVar("GNAv" + i),
			    smt.parseRPNTreeToSMTRule(RPNTreeParser.parseSetToTree(r.getArgument(i))));

		    solver.addAssertion(condRule.toSMTExp());
		}

		if (solver.checkSAT() == YNM.YES) {
		    if (SHOULD_PRINT)
			Logger.getLog().writeln("Derived STEM-Values from the given StartSymbol");
		    for (int i = 0; i < r.getArity(); i++) {
			arr[i + 1] = FunctionSymbol
				.create(this.getValueOfVariableWithinModel(solver.getModel(), "GNAv" + i) + "", 0);
		    }

		} else {
		    Logger.getLog().writeln("There is no possible Startterm");
		    Logger.getLog().close();
		    assert false;
		}
	    } catch (UnsupportetArithmeticSymbolException e) {
		// Create Startvalues 0 in case of unsuspected problem
		for (int i = 0; i < r.getArity(); i++) {
		    TRSTerm arg = r.getArgument(i);
		    arr[i + 1] = FunctionSymbol.create("0", 0);
		}
		e.printStackTrace();
	    }

	}

	return arr;
    }

    /**
     * computes the {@link Loop} by computing the updateMatrix and
     * updateConstants of the {@link Loop} using
     * {@link #deriveUpdatePart(TRSTerm, TRSTerm)} and afterwards computing the
     * guardMatrix with corresponding guardConstants using
     * {@link #deriveGuardPart(IGeneralizedRule)}.
     * 
     * @see GeoNonTermAnalysis#deriveUpdatePart(TRSTerm, TRSTerm)
     * @see #deriveGuardPart(IGeneralizedRule)
     * @see Loop
     */
    private void deriveLOOP() {
	this.loop = new Loop();

	int index = this.getIndexOfSymbol(rules, stem.getStartFunctionSymbol());
	TRSFunctionApplication leftSide = rules[index].getLeft();
	TRSTerm rightSide = rules[index].getRight();

	// Vergleichen des ersten FunctionSymbol der beiden Seiten
	if (leftSide.getFunctionSymbols().toArray(new FunctionSymbol[] {})[0]
		.equals(rightSide.getFunctionSymbols().toArray(new FunctionSymbol[] {})[0])) {
	    // die Regel hat die Form f_x -> f_x :|: cond
	    if (SHOULD_PRINT) {
		Logger.getLog().writeln("Investigating the rule " + rules[index]);
		Logger.getLog().writeln("Rule " + index + " is of the Form: f_x -> f_x :|: cond");
	    }

	    // loop.setDimensions(leftSide.getVariables().size(),
	    // rules[index].getCondTerm().toString().split("&&").length);

	    // Suche aus dem rechten Teil die Updates raus
	    this.deriveUpdatePart(leftSide, rightSide);

	    // suche aus den conditions the Regeln raus
	    this.deriveGuardPart(rules[index]);

	    loop.computeIterationMatrixAndConstants();

	    if (SHOULD_PRINT) {
		Logger.getLog().writeln(Loop.getSystemAsString(loop.getIterationMatrix(),
			new String[] { "x0_0", "x0_1", "x1_0", "x1_1" }, loop.getIterationConstants()));
	    }
	    // Logger.getLog().writeln(rightSide.getSubterm(Position.create(0)).toString());
	} else {
	    // die Regel hat die Form f_x -> f_y :|: cond
	    if (SHOULD_PRINT)
		Logger.getLog().writeln("Rule " + index + " is of the Form: f_x -> f_y :|: cond");
	}
    }

    /**
     * This method derives the update matrix and constants to a given rule, by
     * parsing it into a {@link RPNNode RPNTree} using
     * {@link RPNTreeParser#parseSetToTree(TRSTerm)}. Note: it gets left and
     * right instead of the rule itself, because they are already computed
     * anyway.
     * 
     * @param leftSide
     *            the left side the rule
     * @param rightSide
     *            the right side of the rule.
     */
    private void deriveUpdatePart(TRSTerm leftSide, TRSTerm rightSide) {
	String[] occuringVars = GeoNonTermAnalysis.deriveVariablesAsStringArray(leftSide.getVariables());

	// Es wird versucht die rechte Seite in ein RPNTree zu parsen
	RPNNode[] variableUpdates = new RPNNode[leftSide.getVariables().size()];
	try {
	    for (int i = 0; i < variableUpdates.length; i++)
		variableUpdates[i] = RPNTreeParser.parseSetToTree(rightSide.getSubterm(Position.create(i)));
	} catch (UnsupportetArithmeticSymbolException e) {
	    e.printStackTrace();
	    Logger.getLog().writeln("UnsupportetArithmeticSymbolException: " + e.getMessage());
	} catch (ArrayIndexOutOfBoundsException e) {
	    e.printStackTrace();
	    Logger.getLog().writeln("ArrayIndexOutOfBoundsException: More Vars then Updates");
	}
	GNAMatrix updateMatrix = new GNAMatrix(occuringVars);
	GNAVector updateConstants = new GNAVector(occuringVars.length, 0);

	// Herleiten der Update-Matrix Einträge
	for (int i = 0; i < occuringVars.length; i++) {
	    for (int j = 0; j < occuringVars.length; j++) {
		updateMatrix.setEntry(occuringVars[i], occuringVars[j],
			variableUpdates[i].getFactorOfVar(occuringVars[j]));
	    }
	    updateConstants.set(i, variableUpdates[i].getConstantTerm());
	}
	loop.setUpdateMatrix(updateMatrix);
	loop.setUpdateConstants(updateConstants);
    }

    /**
     * This method derives the guard matrix and constants of a given rule, by
     * parsing only the condition terms into a {@link RPNNode RPNTree} after
     * splitting them into the different rules. <br>
     * So it splits: <code>x_1 > 0 && x_3 > 5</code><br>
     * Into the two conditions and parses them separately.
     * 
     * @param rule
     *            the rule containing the conditions
     */
    private void deriveGuardPart(IGeneralizedRule rule) {

	Pair<GNAMatrix, GNAVector> pair = this.computeConditionMatrixAndConstants(rule);

	GNAMatrix guardMatrix = pair.getKey();
	GNAVector guardConstants = pair.getValue();

	// alle > in < umdrehen, sodass die constante immer < da steht:
	// ... < c
	// UpdateMatrix.negateMatrix(guardMatrix);
	guardMatrix.negate();
	for (int i = 0; i < guardConstants.size(); i++)
	    guardConstants.set(i, guardConstants.get(i) * -1 - 1);

	loop.setGuardUpdates(guardMatrix);
	loop.setGuardConstants(guardConstants);
    }

    private Pair<GNAMatrix, GNAVector> computeConditionMatrixAndConstants(IGeneralizedRule rule) {

	ArrayList<TRSTerm> condTerms = new ArrayList<>();
	Stack<TRSTerm> stack = new Stack<>();
	stack.push(rule.getCondTerm());

	TRSTerm curr;
	while (!stack.isEmpty()) {
	    curr = stack.pop();
	    // Logger.getLog().writeln("investigating: " + curr.toString());
	    if (curr instanceof TRSCompoundTerm) {
		if (((TRSCompoundTerm) curr).getFunctionSymbol().toString().equals("&&_2")) {
		    stack.push(((TRSCompoundTerm) curr).getArgument(0));
		    stack.push(((TRSCompoundTerm) curr).getArgument(1));
		    // Logger.getLog().writeln("TRSCompoundTerm");
		} else {
		    condTerms.add(curr);
		    // Logger.getLog().writeln("Not TRSCompoundTerm");
		}
	    }
	}

	ArrayList<TRSTerm> condTermsReverse = new ArrayList<>();
	for (int i = condTerms.size() - 1; i >= 0; i--) {
	    condTermsReverse.add(condTerms.get(i));
	}
	condTerms = condTermsReverse;

	// Die GuardMatrix für die versch. Bedingungen
	GNAMatrix guardMatrix = new GNAMatrix(condTerms.size(), rule.getRight().getVariables().size(),
		GeoNonTermAnalysis.deriveVariablesAsStringArray(rule.getRight().getVariables()));
	// Die Constanten, welche erfüllt werden müssen
	GNAVector guardConstants = new GNAVector(condTerms.size(), 0);

	// Logger.getLog().writeln("Cond Terms: " + condTerms);
	for (int i = 0; i < condTerms.size(); i++)
	    try {
		RPNNode root = RPNTreeParser.parseSetToTree(condTerms.get(i));
		if (SHOULD_PRINT)
		    Logger.getLog().writeln("Überprüfe: " + root.toString());
		for (TRSVariable var : condTerms.get(i).getVariables()) {
		    if (root.containsVar(var.toString())) {
			if (SHOULD_PRINT)
			    Logger.getLog().writeln("-> beinhaltet " + var.toString() + " mit dem Factor: "
				    + root.getFactorOfVar(var.toString()));
			guardMatrix.setEntry(i, var.toString(), root.getFactorOfVar(var.toString()));
		    }
		}
		guardConstants.set(i, root.getConstantTerm());
	    } catch (UnsupportetArithmeticSymbolException e) {
		e.printStackTrace();
	    }

	Pair<GNAMatrix, GNAVector> pair = new Pair<GNAMatrix, GNAVector>(guardMatrix, guardConstants);

	return pair;
    }

    /**
     * This method try's to derive a {@link GeoNonTermArgument} using a
     * SMT-Solver. <br>
     * It can only do so if before the {@link Stem} and {@link Loop} including
     * {@link Loop#computeIterationMatrixAndConstants()} are computed. Otherwise
     * it's most likely to throw a {@link NullPointerException}. <br>
     * If a {@link GeoNonTermArgument} can be found it will be returned.
     * Otherwise this method will return <code>null</code>.
     * 
     * @return a {@link GeoNonTermArgument} or <code>null</code>
     * 
     * @see Stem
     * @see Loop
     * @see SMTFactory
     */
    private GeoNonTermArgument tryDerivingAGNA() {

	if (gna != null)
	    if (gna.validate(loop.getIterationMatrix(), loop.getIterationConstants()))
		return gna;

	int[] eigenvalues = loop.getUpdateMatrix().computeEigenvalues();

	Z3Solver solver = smt.getSolver();

	// Das berechnen vom Point Kriterium
	smt.addAssertion(loop.getIterationMatrix(), smt.createPointCriteriaVector(stem), loop.getIterationConstants());

	char last = 'a';
	int size = stem.getStemVec().size();
	int xCount = 0;
	for (int i = 0; i < eigenvalues.length; i++) {
	    if (i == 0) {
		smt.addAssertion(loop.getIterationMatrix(), smt.createRayCriteriaVector(size, eigenvalues[i], last));
	    } else {
		smt.addAssertion(loop.getIterationMatrix(),
			smt.createRayCriteriaVector(size, eigenvalues[i], last, "X" + xCount++, (char) (last - 1)));
	    }

	    last = (char) (last + 1);
	}

	// Addition
	smt.addAdditionAssertion(size, last);

	// checking
	Logger.getLog().writeln("SAT: " + solver.checkSAT().toString());
	if (solver.checkSAT() == YNM.YES) {
	    Logger.getLog().writeln("MODEl: " + solver.getModel().toString());

	    int[] muArray = this.createMuFromModel(solver.getModel());
	    GNAVector[] Y = this.createYFromModel(solver.getModel(), last);

	    GeoNonTermArgument gna = new GeoNonTermArgument(stem, Y, eigenvalues, muArray);

	    return gna;
	} else
	    return null;
    }

    /**
     * This method computes from a given {@link Model} the different
     * {@link GNAVector} as columns of the Y-matrix of the
     * {@link GeoNonTermAnalysis}. It does so by creating a vector for every
     * char between 'a' and the given last used char. The char for example 'a'
     * is afterwards used and gets indices to a max., which is the result of
     * {@link #countAppearance(Model, String)} and computes the value using
     * {@link #getValueOfVariableWithinModel(Model, String)}. The declarations
     * within the model get sorted by the index. <br>
     * 
     * <pre>
     * [(define-fun x0 2), (define-fun b1 2), (define-fun b0 14), (define-fun a1 0), (define-fun a0 8), (define-fun s1 2), (define-fun s0 22)]
     *         8   14
     * =&gt; [(0),( 2)]
     * </pre>
     * 
     * @param model
     *            the model of the SMT-Problem
     * @param last
     *            the last char used
     * @return an array of {@link GNAVector GNAVectors} to represent the
     *         variable assignment
     */
    private GNAVector[] createYFromModel(Model model, char last) {
	ArrayList<GNAVector> vectors = new ArrayList<>();

	for (int i = (int) 'a'; i < (int) last; i++) {
	    GNAVector vec = new GNAVector(stem.getStemVec().size(), 0);
	    for (int j = 0; j < vec.size(); j++) {
		vec.set(j, this.getValueOfVariableWithinModel(model, (char) i + "" + j));
	    }
	    vectors.add(vec);
	}

	return vectors.toArray(new GNAVector[vectors.size()]);
    }

    /**
     * This method computes from a given {@link Model} the mu's assignments so
     * that the ray criteria is fulfilled. It derives the assignments of the
     * mu's ordered chronologically by the index using
     * {@link #countAppearance(Model, String)} and
     * {@link #getValueOfVariableWithinModel(Model, String)}. <br>
     * Beispiel:
     * 
     * <pre>
     * [(define-fun X0 2), (define-fun b1 2), (define-fun b0 14), (define-fun a1 0), (define-fun a0 8), (define-fun s1 2), (define-fun s0 22)]
     * =&gt; [2]
     * </pre>
     * 
     * The mu's are written as capital X so that the other variables can contain
     * the lower capital letter 'x' .
     * 
     * @param model
     *            the model of the SMT-Problem
     * @return an <code>int</code>-array with the values of the mu's
     */
    private int[] createMuFromModel(Model model) {
	ArrayList<Integer> mu = new ArrayList<>();

	for (int i = 0; i < this.countAppearance(model, "X"); i++) {
	    // Logger.getLog().writeln("x" + i + ": " + m.get((Symbol<?>)
	    // smt.createVar("x" + i).toSMTExp()));
	    mu.add(this.getValueOfVariableWithinModel(model, "X" + i));
	}

	int[] finalMu = new int[mu.size()];
	for (int i = 0; i < finalMu.length; i++)
	    finalMu[i] = mu.get(i);
	return finalMu;
    }

    /**
     * This method takes a {@link Model} and the name of a desired values
     * variable and computes it's assignment within the model using
     * {@link Model#get(Symbol)} and parsing into <code>int</code>.
     * 
     * @param model
     *            the model of the SMT-Problem
     * @param varName
     *            the name of the variable (with index)
     * @return the assigned value of the variable
     */
    private int getValueOfVariableWithinModel(Model model, String varName) {
	SMTExpression<?> smtExpression = model.get((Symbol<?>) smt.createVar(varName).toSMTExp());
	return Integer.parseInt(smtExpression.toString());
    }

    /**
     * @return The geometric nontermination argument if the analysis was
     *         successful, null else.
     */
    public GeoNonTermArgument getNontermArgument() {
	return this.gna;
    }

    /**
     * This method iterates through the given model and count's the appearances
     * of the given name. <br>
     * NOTE: if the variables would be "aa" and "ab" would be a problem.
     * 
     * @param model
     *            the model of the SMT-Problem
     * @param varName
     *            the name of the variable (without index)
     * @return the number of appearances of the variable
     */
    private int countAppearance(Model model, String varName) {
	int count = 0;

	for (Entry<Symbol<?>, FunctionDefinition> entry : model.getDeclarations().entrySet()) {
	    if (entry.getKey().toString().contains(varName))
		count++;
	}

	return count;
    }

    /**
     * looks up the index of a {@link IGeneralizedRule} in an array that starts
     * with the given {@link FunctionSymbol}
     * 
     * @param rules
     *            the array of {@link IGeneralizedRule}'s
     * @param fs
     *            the query {@link FunctionSymbol}
     * @return den index ( -1 if isn't contained)
     */
    private int getIndexOfSymbol(IGeneralizedRule[] rules, FunctionSymbol fs) {
	int j = -1;
	for (int i = 0; i < this.rules.length; i++) {
	    if (rules[i].getLeft().getFunctionSymbol().equals(fs)) {
		j = i;
		if (SHOULD_PRINT) {
		    Logger.getLog().writeln("##########");
		    Logger.getLog().writeln(rules[i].getLeft().toString() + " matches " + fs.toString());
		    Logger.getLog().writeln("So Rule Nr." + j + " starts with " + fs.toString());
		    Logger.getLog().writeln("##########");
		}
		break;
	    }
	}

	return j;
    }

}
