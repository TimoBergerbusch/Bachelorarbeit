package aprove.Framework.IntTRS.Nonterm.GeoNonTerm;

/**
 * This class represents a Geometric Non-Termination Argument (GNA). It's a
 * artifact generated by the {@link GeoNonTermAnalysis} and can be seen as a
 * proof of non-termination. It can test itself against a matrix and constants
 * given to proof it's correctness. <br>
 * A GNA is a correct GNA if the following four conditions are met:
 * <ol>
 * <li>domain: x_0,x_1,y_0,...,y_k \in R^n</li>
 * <li>init: x_0,x_1 \in STEM (trivial as it is derived from that)</li>
 * <li>point: A*(x_1 x_1+\sum_i y_i) &lt;= b</li>
 * <li>ray: A*(y_i lambda_i*y_i+mu_(i-1)*y_(i-1)) &lt;= 0</li>
 * </ol>
 * 
 * @author Timo Bergerbusch
 * @see GeoNonTermAnalysis
 * 
 */
public class GeoNonTermArgument {
    
    /**
     * the initial values/the starting point
     * 
     * @see Stem
     */
    private Stem x;

    /**
     * a {@link GNAVector}-array representing the collumn's of the Y-matrix. (In
     * the paper it is referred as the direction matrix)
     * 
     * @see GNAVector
     * @see Loop
     */
    private GNAVector[] y;

    /**
     * the eigenvalues of the update-matrix <br>
     * (these are always non-negative)
     * 
     * @see Loop
     */
    private int[] lambda;

    /**
     * the mu-values
     */
    private int[] mu;

    /**
     * creating a new instance with all given parameters. <br>
     * (A partly declaration would be false indication of the existence)
     * 
     * @param x
     *            the {@link Stem}
     * @param y
     *            the direction-matrix-columns
     * @param lambda
     *            the eigenvalues of the update-matrix
     * @param mu
     *            the mu's
     */
    public GeoNonTermArgument(Stem x, GNAVector[] y, int[] lambda, int[] mu) {
	assert y.length == lambda.length;
	assert mu.length == y.length - 1;

	this.x = x;
	this.y = y;
	this.lambda = lambda;
	this.mu = mu;
    }

    /**
     * checks the {@link GeoNonTermArgument} against an {@link GNAMatrix
     * iteration-matrix} and {@link GNAVector iterations-constant}
     * 
     * @param a
     *            the {@link GNAMatrix iteration-matrix}
     * @param b
     *            the {@link GNAVector iteration-constant}
     * @return checks if the 4 criteria's of a {@link GeoNonTermArgument} hold.
     * 
     * @see GeoNonTermArgument
     */
    public boolean validate(GNAMatrix a, GNAVector b) {

	boolean bool = true;

	bool &= this.checkDomainCriteria();
	// since criteria 2 is trivial to check, because of the
	// circumstances I don't check them
	bool &= this.checkPointCriteria(a, b); // check point
	bool &= this.checkRayCriteria(a); // check ray

	return bool;
    }

    /**
     * checking the domain criteria. <br>
     * domain: x_0,x_1,y_0,...,y_k \in R^n
     * 
     * @return a boolean indicating if the criteria holds
     */
    private boolean checkDomainCriteria() {
	boolean bool = true;

	for (int i : lambda)
	    bool &= (i >= 0);

	for (int i : mu)
	    bool &= (i >= 0);

	return bool;
    }

    /**
     * checking the point criteria. <br>
     * point: A*(x_1 x_1+\sum_i y_i) &lt;= b
     * 
     * @param a
     *            the {@link GNAMatrix iteration-matrix}
     * @param b
     *            the {@link GNAVector iteration-constant}
     * @return a boolean indicating if the criteria holds
     */
    private boolean checkPointCriteria(GNAMatrix a, GNAVector b) {

	GNAVector sum = y[0];
	for (int i = 1; i < y.length; i++) {
	    // sum = GeoNonTermAnalysis.add(sum, y[i]);
	    sum = sum.add(y[i]);
	}

	GNAVector vec = new GNAVector();

	vec.pushAll(x.getStemVec());
	// vec.pushAll(GeoNonTermAnalysis.add(x.getStemVec(), sum));
	vec.pushAll(sum.add(x.getStemVec()));

	if (!checkHolding(a, vec, b)) {
	    Logger.getLog().writeln("PointCriteria doesn't hold");
	    return false;
	}

	return true;
    }

    /**
     * checking the ray criteria. <br>
     * ray: A*(y_i lambda_i*y_i+mu_(i-1)*y_(i-1)) &lt;= 0
     * 
     * @param a
     *            the {@link GNAMatrix iteration-matrix}
     * @return a boolean indicating if the criteria holds
     */
    private boolean checkRayCriteria(GNAMatrix a) {
	GNAVector vec = new GNAVector();
	GNAVector nullen = new GNAVector();
	for (int entry = 0; entry < a.rowSize(); entry++) {
	    nullen.push(0);
	}

	for (int i = 0; i < y.length; i++) {

	    vec.pushAll(y[i]);
	    if (i == 0)
		// vec.pushAll(GeoNonTermAnalysis.mult(y[i], lambda[i]));
		vec.pushAll(y[i].mult(lambda[i]));
	    else
		// vec.pushAll(GeoNonTermAnalysis.add(GeoNonTermAnalysis.mult(y[i],
		// lambda[i]),
		// GeoNonTermAnalysis.mult(y[i - 1], mu[i - 1])));
		vec.pushAll(y[i].mult(lambda[i]).add(y[i - 1].mult(mu[i - 1])));

	    if (!this.checkHolding(a, vec, nullen)) {
		Logger.getLog().writeln("RayCriteria of index: " + i + "doesn't hold!");
		Logger.getLog().writeln(Loop.getSystemAsString(a, vec, nullen));
		return false;
	    }
	    vec.clear();
	}

	return true;
    }

    /**
     * a helping function to check if for a given {@link GNAMatrix}
     * <code>a</code>, {@link GNAVector} <code>vec</code> and {@link GNAVector}
     * <code>b</code> if a*vec &lt;=b holds.
     * 
     * @param a
     *            a {@link GNAMatrix}
     * @param vec
     *            a {@link GNAVector}
     * @param b
     *            a {@link GNAVector}
     * @return a boolean indicating if a*vec &lt;=b holds
     */
    private boolean checkHolding(GNAMatrix a, GNAVector vec, GNAVector b) {
	vec = a.mult(vec);

	return vec.lessOrEqualThan(b);
    }
}
