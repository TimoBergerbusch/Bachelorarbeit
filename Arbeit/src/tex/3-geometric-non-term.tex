\chapter{Geometric Non-Termination}

Now that all preliminaries are stated we can start looking how the approach works within \aprove. To find a \gna and so prove nontermination we use \aprove to generate an \its of a given program. %TODO: write how? ref: prelim
Based on the calculated \its we derive the \stem, the \loopt and then generate an \tool{SMT}-Problem using \autoref{def:gna} and compute a \gna, which would be a prove of nontermination, or state that no \gna can exist, which does not infer termination nor nontermination.

\section{Derivation of the \emph{STEM}}
\label{sec:stem}
The derivation of the \stem is the first step to do in order to derive a \gna. As described in \autoref{sec:structure} the \stem defines the variables before iterating through the \loopt.  Owned to the fact, that \aprove has to find the a loop within the generated symbolic execution graph %TODO: cite
one iteration through the \loopt will be calculated. Obviously this does not falsify the result. If it does not terminate i will still not terminate after one iteration and if it terminates after $n$ iterations and we compute one it will still terminate after $n-1$ iterations. \newline
Within the derivation of the \stem we distinguish between two cases discussed in the following sections.

\subsection{Constant \stem}
\label{sec:stem-const}

\newsavebox{\stemexone}% Box to store smallmatrix content
\savebox{\stemexone}{$\begin{pmatrix}10\\2\end{pmatrix}$}
\begin{wrapfigure}{r}{0.6\textwidth}
	\begin{lstlisting}[escapechar=!]
	!$f_1 \rightarrow f_2(10,2) :|: TRUE $!
	\end{lstlisting}	
	\caption{An example of a constant \its rule to derive the \stem. The \stem in this case would be \usebox{\stemexone} }
	\label{lst:stem-cons}
\end{wrapfigure}

The constant stem is the easiest case to derive the \stem from. It has the form: 
%\vspace{-1em}
\begin{figure}[H]
	$f_x \rightarrow f_y(c_1,\dots c_n) :|: TRUE$
\end{figure} 
%\vspace{-2em}
An example of a constant \stem is shown in \autoref{lst:stem-cons}. 
The values of $x$ can be directly read from the right hand side and need no further calculations.

\subsection{Variable \stem}
\label{sec:stem-var}
The more complex case is given if the start function symbol has the following form:
\begin{figure}[H]
	\hspace{2cm}
	$f_x \rightarrow f_y(v_1, \dots v_n) :|: cond$
\end{figure}
%\vspace{-1em}
where $v_i$ $1 \le i \le n$ is either a constant term like in \autoref{sec:stem-const} \underline{or} a variable defined by the $cond$ term. An example for such a \stem is shown in \autoref{lst:stem-var}. In order to derive terms in $\mathbb{Z}$ an \tool{SMT}-Problem needs to be solved. We can compute the \guardmatrix, \guardconstants, \updatematrix and \updateconstants of the start function symbol and use the \smtfactory, which we will explain in %TODO: ref
, to create the assertions leading to either an assignment of $x$ to a value or to a unsatisfiable core. Such a core would state, that the \code{while}-Loop would not hold after any assignment and therefore prove termination.
%TODO: im code: wenn unsat dann termination

\newsavebox{\stemextwo}% Box to store smallmatrix content
\savebox{\stemextwo}{$\begin{pmatrix}1+3*3\\2\end{pmatrix}$}
\newsavebox{\stemextwosecond}% Box to store smallmatrix content
\savebox{\stemextwosecond}{$\begin{pmatrix}10\\2\end{pmatrix}$}
\begin{figure}[H]
	\begin{lstlisting}[escapechar=!]
	!$f_1 \rightarrow f_2(1 + 3 * v, 2) :|: v > 2\text{ \&\& }8 < 3 * v $!
	\end{lstlisting}	
	\caption{An example of a variable \its rule to derive the \stem. In order to derive it an $v$ fulfilling the conditions need to be found using an \tool{SMT}-Solver. Since $v=3$ is the first number in $\mathbb{Z}$ that satisfies the guards the \stem would be \usebox{\stemextwo}$=$\usebox{\stemextwosecond} }
	\label{lst:stem-var}
\end{figure}

\section{Derivation of the \emph{LOOP}}

The derivation of the \loopt is pretty straight forward applying \autoref{def:guard}, \autoref{def:update} to a looping rule and then computing \iterationmatrix and \iterationconstants using \autoref{def:iteration}. \newline
Let $f_x$ be the starting function symbol given by the \its and $r_i$ be a rule, with 
\begin{lstlisting}[escapechar=!]
	!$f_x \rightarrow f_y(v_1, \dots, v_n) :|: cond_1$!
\end{lstlisting} 
then we take the in lexicographical order first rule $r_l$ of the form 
\begin{lstlisting}[escapechar=!]
	!$f_y(v_1, \dots, v_n) \rightarrow f_y(v^\prime_1, \dots, v^\prime_n) :|: cond_2$!
\end{lstlisting}
and compute the \iterationmatrix and \iterationconstants according to $r_l$. 

\subsection{The Update Matrix}
The derivation of the \updatematrix and \updateconstants is relatively just applying the \autoref{def:update} to the given rule $r_l$. For that we create a matrix $U$ as the coefficient matrix. We do so by adding a column per occurring variable and rows per linear equation of every $v^\prime_i$. To derive the entry's of the matrix we use the \rpntree to build a tree of the given equation and simply perform recursive searching to derive the factor. 
%Also we can use
The procedure works like the following:
\begin{algorithm}
	\caption{Deriving a coefficient within the \rpntree}
	\label{algo:coefficient}
	\begin{algorithmic}[1]
		\Procedure{getCoefficient}{$node, query$}
			\If{node == query}\Comment{query is the tree}
				\State \Return $1$
			\ElsIf{node does \underline{not} contain query} \Comment{tree does not contain query}
				\State \Return $0$
			\EndIf
			\State
			\If{node represents PLUS} \Comment{Choose the subtree containing the query}
				\If{left side contains $query$}
					\State \Return getCoefficient$(node.left, query)$
				\Else
					\State \Return getCoefficient$(node.right, query)$
				\EndIf
			\EndIf
			\If{node represents TIMES} \Comment{Retrieve value}
				\If{node.right == query}
					\State \Return node.left.value
				\EndIf				
			\EndIf
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
\begin{figure}
	\tikzstyle{abstract}=[rectangle, draw=black, rounded corners, text centered, anchor=north, rectangle split, rectangle split parts=2]
	\tikzstyle{myarrow}=[->, thick]
	\tikzstyle{considered}=[myarrow, color = blue]
	\tikzstyle{neglected} = [myarrow, color = red]
	\tikzstyle{query} = [myarrow, color = green!50!black]
	\begin{tikzpicture}
		\node (Plus) at (0,0) [abstract] {
				\textbf{f1}:RPNFunctionSymbol
				\nodepart{second}arithmeticSymbol: PLUS
			};
		\node (Times1) at (-4, -2 ) [abstract] {
				\textbf{f2}:RPNFunctionSymbol
				\nodepart{second}arithmeticSymbol: TIMES	
		};
		\node (Times2) at (4, -2) [abstract] {
			\textbf{f3}:RPNFunctionSymbol
			\nodepart{second}arithmeticSymbol: TIMES	
		};
		\node (cons1) at (-6, -4) [abstract] {
			\textbf{c1}:RPNConstant
			\nodepart{second}value: 2
		};
		\node (var1) at (-2, -4)[abstract] {
			\textbf{v1}:RPNVariable
			\nodepart{second}varName: x
		};
		\node (cons2) at (2, -4) [abstract] {
			\textbf{c2}:RPNConstant
			\nodepart{second}value: 4
		};
		\node (var2) at (6, -4) [abstract] {
			\textbf{v2}:RPNVariable
			\nodepart{second}varName: y
		};
		\draw[neglected] (Plus.south)  -- ++(0,-0.4) -| (Times1.north) node [pos = 0.4, above, font=\footnotesize]{left};
		\draw[considered] (Plus.south)  -- ++(0,-0.4) -| (Times2.north) node [pos = 0.4, above, font=\footnotesize]{right};
		\draw[myarrow] (Times1.south)  -- ++(0,-0.5) -| (cons1.north) node [pos = 0.4, above, font=\footnotesize]{left};
		\draw[myarrow] (Times1.south)  -- ++(0,-0.5) -| (var1.north) node [pos = 0.4, above, font=\footnotesize]{right};
		\draw[considered] (Times2.south)  -- ++(0,-0.5) -| (cons2.north) node [pos = 0.4, above, font=\footnotesize]{left};
		\draw[query] (Times2.south)  -- ++(0,-0.5) -| (var2.north) node [pos = 0.4, above, font=\footnotesize]{right};
	\end{tikzpicture}
	\caption{An example of deriving the coefficient of a given formula and a variable as query. Used the \autoref{ex:rpntree} and marked the way of deriving the coefficient.}
	\label{ex:factor-derivation}
\end{figure}

\subsection{The Guard Matrix}

\subsection{The Iteration Matrix}

\section{Derivation of the \emph{SMT}-Problem}

\subsection{The Domain Criteria}

\subsection{The Initiation Criteria}

\subsection{The Point Criteria}

\subsection{The Ray Criteria}

\section{Verification of the Geometric Non-Termination Argument}
	 
