\chapter{Evaluation and Benchmark}
\label{chapter:eval}
In this chapter we want to take a look at the implementation and evaluate, if the approach itself is useful in terms of applicable cases or if the approach works only on very exotic and uncommon preconditions. \newline
Also we want to take a look at the benchmarks of the implementation, in terms of storage and computational efficiency.\newline
Further we want to outline improvement possibilities of the implementation and problems within, where an efficient solution is not quite obvious.

\section{Evaluation of the approach}
The approach provides a sound and complete solution to specific type of programs. Given a tool like \aprove, which provides a normalized and shortened \its the further computation that has to be done can be solved quite efficient. Using an state of the art \solver and the definition of $\lambda_i$ to be the $i$-th eigenvalue the problem can also be resolved efficiently for given $\mu$'s. If the $\mu$'s are not given the problem is undecidable, which makes it still useful within \aprove, but not as strong as before. \newline

\section{Benchmarks}

\section{Possible Improvement of the Implementation}
The implementation of the approach is fully functional under the circumstances mentioned, like for example the defined structure in \autoref{sec:structure}. Nevertheless also this implementation has certain cases in, which it does not perform as efficient as it could.
So here we state the possible improvements of the implementation to make it universally more useful and therefore stronger or more efficient.
\subsection{\solver logic}
As already stated in \autoref{sec:derivation-smt} the problematic of the $\mu$'s can lead to a shift into undecidability, since the solvating of variable multiplication on integers (\qfnia) is undecidable. Also mentioned in \autoref{sec:derivation-smt} there are a bunch of approaches, which lead to semi-decidability and therefore to the possibility to still use the variable multiplication within the problem if the $\mu$'s can be restricted to a finite domain.\newline
A possible improvement could be an iteration over different values of the $\mu$'s. The number of problems, that have to be solved would be blow up, but the problem itself would always be decidable.\newline
A reliable case-study of a large set of examples could underline the necessity of the iteration, since we wouldn't be able to derive a \gna using the \qfnia. It could also lead to the overhead of computational cost using the iterative method, which can be useful if the problem does not have any time restrictions of the deciding process, but is not suitable within the competitions \aprove participates, like the \textit{International Competition of Termination Tools} \footnote{ further information: \url{http://termination-portal.org/wiki/Termination_Competition} } or \textit{International Competition on Software Verification} \footnote{further information: \url{https://sv-comp.sosy-lab.org/2017/}}. \cite{aproveWebsite} \newline
The \textit{Termination Competition 2017}, which is organized by the \textit{International Competition of Termination Tools}, for example has a time limit of 300 seconds and only allows 4 core usage, which makes an iterative method very costly. \cite{wiki2017termComp}

\subsection{\its program structure}
\label{sec:structure-improvement}
As stated in \autoref{sec:structure} we restrict this implementation to the form 
\begin{figure}[H]
	\begin{lstlisting}[escapechar=!]
	!$f_x \qquad\qquad \>\> \rightarrow f_y (v_1, \dots v_n) \> :|: cond_1$!
	!$f_y(v_1, \dots v_n) \> \rightarrow  f_y \>(v^\prime_1,\dots v^\prime_n)  :|: cond_2$!
	\end{lstlisting}
\end{figure}
which obviously is a restriction, because \its's of the form
\begin{figure}[H]
	\begin{lstlisting}[escapechar=!]
	!$f_x \qquad\qquad \>\ \rightarrow f_y (v_1, \dots v_n) \> :|: cond_1$!
	!$f_{y_1}(v_1, \dots v_n) \> \rightarrow  f_{y_2} \>(v^\prime_1,\dots v^\prime_n)  :|: cond_2$!
			!$\vdots$!
	!$f_{y_k}(v_1, \dots v_n) \> \rightarrow  f_{y_1} \>(v^\prime_1,\dots v^\prime_n)  :|: cond_{k+1}$!
	\end{lstlisting}
\end{figure}
could possibly considered using the method $k$ times. Analysing such \its would make the implementation much stronger in terms of proofing.
\\
An other possible variation of the considered \its could be like the following
\begin{figure}[H]
	\begin{lstlisting}[escapechar=!]
	!$f_x \qquad\qquad \>\>\>\> \rightarrow f_y (v_1, \dots v_n) \> :|: cond_1$!
	!$f_{y_1}(v_1, \dots v_n) \> \rightarrow  f_{y_2} \>(v^\prime_1,\dots v^\prime_m)  :|: cond_2$!
	!$f_{y_2}(v_1, \dots v_m)  \rightarrow  f_{y_1} \>(v^\prime_1,\dots v^\prime_n)  :|: cond_3$!
	\end{lstlisting}
\end{figure}
where $m \ne n$, but the values $v^\prime_i$ $1 \le i \le m$ is computed as a linear update of the values $v_j$ $1 \le j \le n$.

These are only two alternations of the considered structure, which would be also recommended to implement in order to create a more universal applicable method.