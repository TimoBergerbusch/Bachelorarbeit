\chapter{Evaluation and Benchmarks}
\label{chapter:eval}
In this chapter we want to take a look at the implementation and evaluate if the approach is useful in terms of applicable cases or if the approach works only on uncommon preconditions. \newline
Also we want to take a look at the benchmarks of the implementation in computational efficiency. \newline
Further we want to outline possibilities to extend and improve the implementation and and current problems in cases where an efficient solution is not quite obvious.

\section{Evaluation of the Approach}
The approach provides a sound solution to specific types of programs. Given a tool like \aprove which provides an \its, the further computation that has to be done can be solved quite efficiently. Using a state-of-the-art \solver and the definition of $\lambda_i$ to be the $i$-th eigenvalue, the problem can also be resolved efficiently for given $\mu_i$. If the $\mu_i$ are not given, the problem is undecidable, which makes it still useful within \aprove but not as strong as before. \newline
Since the original approach does not mention equalities within the guards, the substitution of newly introduced variables as handled within \Cref{sec:derivation-guard} is necessary in order to apply the definition. Such a substitution is very costly in computation time and also highly error prone.

\section{Benchmarks}
\label{sec:benchmarks}
In order to discuss the possibilities of improvement regarding the implementation, we want to take a look at the performance. For that we compared \aprove with all its techniques to \aprove only running the \gnanal. The set of example programs is taken from the Termination category of the SV-COMP \cite{SVComp}.\newline
Detailed results of all programs can be found in \cite{Benchmark}. Not all of the programs are non-terminating and also the set includes non-terminating programs, which do not meet the stated preliminaries. An overview is given below.

\begin{figure}[H]
	\centering
	\begin{tabular}{rlrl}
		number of programs 	& 847 & $\varnothing$-time for termination & +0.0078 sec \\
		applicable programs & 53 & $\varnothing$-time for \nonterm & -1.2675 sec \\
		false pos./neg. & 0 & $\varnothing$-time save overall & 0.76 sec \\
	\end{tabular}	
\end{figure}

Regarding the average duration it takes \aprove to prove these programs, which is 4.513 seconds, an average time saving of 0.76 seconds, which is 17 percent, is observed. Keeping in mind that the \gnanal has the objective of proving \nonterm and that \aprove uses approaches in parallel the save can be even bigger. \aprove stops if any approach returns a proof. So if more than one proof is found, all but the fastest proof do not affect the average saving of time. \newline

\begin{figure}[H]
	\begin{lstlisting}[language = java]
	int main(void){
		int a = __VERIFIER_nondet_int();
		int b = __VERIFIER_nondet_int();
		int c = __VERIFIER_nondet_int();
		
		while (a+b+c >= 4) {
			a = b;
			b = a+b;
			c = b-1;
		}
		return 0;
	}
	\end{lstlisting}
	\caption{A program \aprove cannot prove \nonterm for without the \gnanal}
	\label{fig:program-newproof}
\end{figure}
Also there are programs, like the program shown in \Cref{fig:program-newproof}, which \aprove cannot prove \nonterm for without using the \gnanal. Including this technique to the set of approaches \aprove is able to prove \nonterm. So the set of provable programs gets extended and improves \aprove.


\section{Possible Improvement of the Implementation}
The implementation of the approach is fully functional under the circumstances mentioned, like for example the defined structure in \Cref{sec:structure}. Nevertheless also this implementation has certain cases in which it does not perform as efficient as it could, or where it can be improved in terms of applicability.
So here we state the possible improvements of the implementation to make it applicable to more cases and therefore stronger or more efficient.
\subsection{Choosing a Logical Fragment}
As already stated in \Cref{sec:derivation-smt} the difficulty of the $\mu_i$ leads to a shift into undecidability, since variable multiplication on integers is non-linear. Also mentioned in \Cref{sec:derivation-smt} there are a bunch of approaches which lead to semi-decidability and therefore to the possibility to still use the variable multiplication within the problem if the $\mu_i$ can be restricted to a finite domain.\newline
A possible improvement could be an iteration approach over different values of the $\mu_i$. The number of problems that have to be solved would blow up but the problems themselves would be decidable.\newline
For the examples of the International Competition on Software Verification, we estimate the method that we chose more suitable. In general, a reliable case study could give an indication of the advantages and disadvantages of the two approaches.
%A reliable case study of a large set of examples could underline the necessity of the iteration since we wouldn't be able to derive a \gna using the \qfnia. It could also lead to the overhead of computational cost using the iterative method, which can be useful if the problem does not have any time restrictions of the deciding process, but is not suitable within the competitions \aprove participates, like the \textit{International Competition of Termination Tools} or \textit{International Competition on Software Verification} \cite{aproveWebsite} \cite{TermComp} \cite{SVComp}. \newline
%The \textit{Termination Competition 2017}, which is organized by the \textit{International Competition of Termination Tools}, for example has a time limit of 300 seconds and only allows 4 core usage, which makes an iterative method very costly \cite{wiki2017termComp}.

\subsection{The \stem derivation}
Within this thesis we considered the \stem to be derived from the \its without any dependence to the \loopt. Based on a specific \stem we try to derive a \gna. A stronger approach would be if the \stem would included in the derivation of a \gna. So we combine the set of assertions from \Cref{sec:stem-var} and add them to the \solver of \Cref{sec:derivation-smt}. Not restricting the \gna to one particular \stem we would consider any \stem that fulfils the conditions. This could prove \nonterm for programs, which have a \gna for a \stem that is not the possible first \stem given from the solver as used in this thesis.

\subsection{\its program structure}
\label{sec:structure-improvement}
As stated in \Cref{sec:structure} we restricted our implementation to \itss of the form 
\begin{figure}[H]
	\begin{lstlisting}[escapechar=!]
	!$f_x \qquad\qquad \>\> \rightarrow f_y (v_1, \dots v_n) \> :|: cond_1$!
	!$f_y(v_1, \dots v_n) \> \rightarrow  f_y \>(v^\prime_1,\dots v^\prime_n)  :|: cond_2$!
	\end{lstlisting}
\end{figure}
This obviously is a restriction, because \itss of the form
\begin{figure}[H]
	\begin{lstlisting}[escapechar=!]
	!$f_x \qquad\qquad \>\ \rightarrow f_y (v_1, \dots v_n) \>\>\> :|: cond_1$!
	!$f_{y_1}(v_1, \dots v_n) \> \rightarrow  f_{y_2} \>(v^\prime_1,\dots v^\prime_n)  :|: cond_2$!
			!$\vdots$!
	!$f_{y_k}(v_1, \dots v_n) \> \rightarrow  f_{y_1} \>(v^\prime_1,\dots v^\prime_n)  :|: cond_{k+1}$!
	\end{lstlisting}
\end{figure}
could possibly be considered by compressing the rules into one rule using multiple equalities and concatenation of the conditional terms. Analysing such \itss would make the implementation much stronger.
\\
Another possible variation of the considered \itss could be of the form
\begin{figure}[H]
	\begin{lstlisting}[escapechar=!]
	!$f_x \qquad\qquad \>\>\>\> \rightarrow f_y (v_1, \dots v_n) \>\> :|: cond_1$!
	!$f_{y_1}(v_1, \dots v_n) \> \rightarrow  f_{y_2} (v^\prime_1,\dots v^\prime_m)  :|: cond_2$!
	!$f_{y_2}(v_1, \dots v_m)  \rightarrow  f_{y_1} (v^\prime_1,\dots v^\prime_n) \> :|: cond_3$!
	\end{lstlisting}
\end{figure}
where $m \ne n$ but the values $v^\prime_i$, $1 \le i \le m$, are computed as linear updates of the values $v_j$, $1 \le j \le n$.

These are only two extensions of the considered structure, which would be also recommended to implement in order to create a more universally applicable method.

\subsection{\rpntree}
In \Cref{sec:rpntree} we defined the \rpntree, on which we base the arithmetic computations and statements. \aprove also uses a tree structure to handles such statements with. We chose \rpntrees structure because of two reasons:
\begin{enumerate}
	\item The structure \aprove uses is much more complex but also much more powerful, which made programming a lot more difficult. Parsing it into a tree which can only contain elements expected to be in such expressions not only works equivalently, but it also prevents errors if \aprove's structure gets extended or changed. The \code{RPNTreeParser} handles the conversion and therefore can be seen as an adapter which filters every \its that must not occur in geometric non-termination analysis as stated in this thesis.
	\item Many algorithms are difficult to implement if not programmed recursively. Since extending the existing classes was no option, and inheritance would not work because of restricted visibility, creating my own structure was a simple workaround.
\end{enumerate}
The examples we tested have been small enough to not create any problems with the conversion and possibly less efficient methods, but if applied to huge problems a converting of the approach to work on the structure \aprove uses would be the better way.