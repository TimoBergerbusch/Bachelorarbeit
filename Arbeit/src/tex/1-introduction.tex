\chapter{Introduction}

\section{Motivation}
\label{sec:aprove}
The topic of verification and termination analysis of software increases in importance with the development of new programs. Even though for Turing complete programming languages the \textit{halting problem} is undecidable, and therefore no complete and sound method to decide termination can exist, a variety of approaches are researched and still being developed. These approaches try to prove (non-)termination on programs, which match certain criteria in form of structure, composition or using only a closed set of operations for example only linear updates of variables. Many of these subsets are still Turing complete and therefore these approaches prove soundness but not completeness. \newline %%TODO: redo maybe?
Given a tool which can provide a sound mechanism to prove termination, an optimized framework could analyse written code and find bugs before the actual release of the software \cite{verschaetse1993automatic}. Contemplating that automatic verification can be applied to termination proved software the estimated annual US economy loss of \$60 billion each year in costs associated with software maintenance could be reduced significantly \cite{zhivich2009real}. \newline
%\section{\aprove}
One promising approach is the tool \aprove (\underline{A}utomated \underline{Pro}gram \underline{V}erification \underline{E}nvironment) developed at the RWTH Aachen, Lehr- und Forschungsgebiet Informatik 2. The tool (further only called \aprove) for automatic termination and complexity analysis proves termination for programs of various programming language paradigms like \tool{Java} (object oriented), \tool{Haskell} (functional), \tool{Prolog} (logical) as well as \tool{rewrite systems}.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\node[aproveNode] at (0,0) (java) {Java};
		\node[aproveNode]at (0,-.75) (c) {C};
		\node[aproveNode] at (0,-1.5) (haskell) {Haskell};
		\node[aproveNode] at (0,-2.25) (prolog) {Prolog};
		\node[shape = circle, draw,align = center] at (3, -1.125) (seg) {Symbolic\\ Execution\\ Graph};
		\node[stdNode] at (6,-.75) (its) {ITS};
		\node[stdNode, minimum width = 3cm] at (10,-.25) (comp) {Complexity};
		\node[stdNode, minimum width = 3cm] at (10,-1) (term) {Termination};
		\node[stdNode, minimum width = 3cm] at (10,-1.75) (nterm) {Non-Termination};
		
		\draw[thickarrow] (java) edge (seg);
		\draw[thickarrow] (c) edge (seg);
		\draw[thickarrow] (haskell) edge (seg);
		\draw[thickarrow] (prolog) edge (seg);
		
		\draw[thickarrow] (seg) edge (its);
		\draw[thickarrow] (seg) edge (nterm.west);
		
		\draw[thickarrow] (its) edge (term);
		\draw[thickarrow] (its) edge (comp);
		\draw[thickarrow] (its) edge (nterm);
		
		\draw [thick,decoration={brace,mirror},decorate] (-1,-2.75) -- (3.9,-2.75) 
		node [pos=0.5,anchor=north,yshift=-0.3cm] {\footnotesize Frontends}; 
		
		\draw [thick,decoration={brace,mirror},decorate] (5.2,-2.75) -- (11.5,-2.75) 
		node [pos=0.5,anchor=north,yshift=-0.3cm] {\footnotesize Backend}; 
	\end{tikzpicture}
%	\caption{Schematic partition of the proving process of \aprove adapted from \cite{giesl2017analyzing}}
	\label{fig:aprove-graph}
\end{figure}
\aprove is able to transfer the language \tool{C\\} into \textit{Low Level Virtual Machine (\llvm)}code using the tool \tool{Clang}. \cite{CLANG} Among others these \llvm-programs can be converted into a so called \seg. This graph represents all possible computations of the input program. If this graph contains \lasso s, which are strongly connected components (SCC) and the corresponding path from the root to the SCC, \aprove derives so called (integer) transition systems (\its). A mathematical definition can be found within \cite{fuhs2009proving}. The construction of such an \its fulfils the property that one can extrapolate the termination of the program if the \its terminates. In special cases one can also extrapolate nontermination. Regarding such a case it is proven that the non-termination of (at least) one \its implies non-termination of the program. A more detailed description of the process is stated in \cite{DBLP:stroder} \cite{giesl2017analyzing}.

\section{Overview}
\label{sec:overview}
This thesis provides the introduction to the topic of termination analysis. We focus on the very basic steps because of the huge variety of possible approaches and related methods. Any further knowledge about termination analysis techniques and how they are applied within \aprove can be found in the related papers \cite{giesl2017analyzing}, \cite{giesl2006aprove}, \cite{DBLP:stroder}, \cite{giesl2003aprove}.\newline
In \Cref{chapter:preliminaries} some preliminaries needed to understand the contributions of this thesis are defined. It covers most essential definitions such as that of nontermination, topics of basic knowledge about \textit{Integer Transition Systems} and their structure as it is considered in this thesis. Also \gnas, which build the main constituent, and mathematical knowledge needed to find GNAs are defined. Finally we take a look at the topic of \tool{SMT}-solving and declare the essential parts used within the implementation of the approach.\newline
\Cref{chapter:geo-non-term} deals with the derivation of the different parts resulting in a \tool{SMT}-problem, which provides a \gna if it exists. \newline
At the end, we want to take a look at the usability of the approach. We also want to point out possible adaptations and improvements of the implementation of this approach.