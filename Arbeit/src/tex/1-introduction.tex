\chapter{Introduction}

\section{Motivation}
The topic of verification and termination analysis of software increases in importance with the development of new programs. Even though that for Touring Complete programming languages the \textit{halting problem} is undecidable, and therefore no complete and sound method can exist, a verity of approaches to determine termination are researched and still being developed. These approaches can determine termination on programs, which match certain criteria in form of structure, composition or using only a closed set of operations for example only linear updates of variables. \newline
Given a tool, which can provide a sound and in many scenarios applicable mechanism to prove termination, an optimized framework could analyse written code and find bugs before the actual release of the software \cite{verschaetse1993automatic}. Contemplating that automatic verification can be applied to termination proved software the estimated annual US Economy loses of \$60 billion each year in costs associated software maintenance could be reduced significantly \cite{zhivich2009real}. \newline

\section{\emph{AProVE}}
\label{sec:aprove}
One promising approach is the tool \aprove (\underline{A}utomated \underline{Pro}gram \underline{V}erification \underline{E}nvironment) developed at the RWTH Aachen by the Lehr- und Forschungsgebiet Informatik 2. The \emph{AProVE}-tool (further only called \aprove) for automatic termination and complexity proving works with different programming languages of major language paradigms like \tool{Java} (object oriented), \tool{Haskell} (functional), \tool{Prolog} (logical) as well as \tool{rewrite systems}.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\node[aproveNode] at (0,0) (java) {Java};
		\node[aproveNode]at (0,-.75) (c) {C};
		\node[aproveNode] at (0,-1.5) (haskell) {Haskell};
		\node[aproveNode] at (0,-2.25) (prolog) {Prolog};
		\node[shape = circle, draw,align = center] at (3, -1.125) (seg) {Symbolic\\ Execution\\ Tree};
		\node[stdNode] at (6,-.75) (its) {\its};
		\node[stdNode, minimum width = 3cm] at (10,-.25) (comp) {Complexity};
		\node[stdNode, minimum width = 3cm] at (10,-1) (term) {Termination};
		\node[stdNode, minimum width = 3cm] at (10,-1.75) (nterm) {Non-Termination};
		
		\draw[thickarrow] (java) edge (seg);
		\draw[thickarrow] (c) edge (seg);
		\draw[thickarrow] (haskell) edge (seg);
		\draw[thickarrow] (prolog) edge (seg);
		
		\draw[thickarrow] (seg) edge (its);
		\draw[thickarrow] (seg) edge (nterm.west);
		
		\draw[thickarrow] (its) edge (term);
		\draw[thickarrow] (its) edge (comp);
		\draw[thickarrow] (its) edge (nterm);
		
		\draw [thick,decoration={brace,mirror},decorate] (-1,-2.75) -- (3.9,-2.75) 
		node [pos=0.5,anchor=north,yshift=-0.3cm] {\footnotesize Frontends}; 
		
		\draw [thick,decoration={brace,mirror},decorate] (5.2,-2.75) -- (11.5,-2.75) 
		node [pos=0.5,anchor=north,yshift=-0.3cm] {\footnotesize Backend}; 
	\end{tikzpicture}
	\caption{Schematic partition of the derivation process of \aprove adapted from \cite{giesl2017analyzing}}
	\label{fig:aprove-graph}
\end{figure}
\aprove is able to unify different languages into one structure by converting programs of specific languages like \tool{C} into \textit{Low Level Virtual Machine(\llvm)}-code using the tool \tool{Clang} \footnote{further information: \url{https://clang.llvm.org/}}. Among others these \llvm-programs can be converted into a so called \seg. This graph represents all possible computations of the input program. If this graph contains \lasso's, which are strongly connected components (SCC) and the corresponding path from the root to the SCC, \aprove derives so called (integer) term rewrite systems (further only called \its)\footnote{a mathematical definition can be found within \cite{fuhs2009proving}}. By adding conditions to the \its rules the solution space gets restricted and therefore the \its under-approximates. From that it is proven that the non-termination of (at least) one \its implies non-termination of the program. A more detailed description of the process is stated in \cite{hensel2017aprove} \newline
The conversion of different languages into \its and subsequently applying various different approaches is what makes this tool strong in meanings of proofing \cite{giesl2017analyzing}.

\section{Overview}
\label{sec:overview}
This paper provides the introduction to the topic of termination analysis. We focus on the very basic steps, because of the huge variety of possible approaches and related methods. Any further knowledge about termination analysis techniques and how they are applied within \aprove can be found in the related papers \cite{giesl2017analyzing}, \cite{giesl2006aprove}, \cite{giesl2003aprove}.\newline
Within \Cref{chapter:preliminaries} some preliminaries used within the paper are defined to create a well-defined base for any further argumentation and derivation. It covers the most essential definition of the this thesis, which is the nontermination, topics of basic knowledge about \textit{Integer Term Rewrite Systems} and it's within this approach considered subset based on it's structure. Also the definition of the \gna, which builds the main constituent, and any strongly related matrices are defined. Also we define a tree-structure, which we use to handle arithmetical terms containing variables. Last we take a glimpse at the topic of \tool{SMT}-solving and declare the essential parts used within the implementation of the approach.\newline
The main chapter, which is \Cref{chapter:geo-non-term}, deals with the derivation of the \stem part, for constant or variable terms, the derivation of the \loopt with all it's matrices and finally the derivation of the \tool{SMT}-Problem, which provides a \gna if it exists. \newline
At the end, we want to take a look at the usability of the approach itself. Also we want to point out possible adaptations and improvements of the implementation of this approach.