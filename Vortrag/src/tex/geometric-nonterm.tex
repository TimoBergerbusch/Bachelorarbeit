\section{Geometric Nontermination}

\frame{\tableofcontents[currentsection]}

\begin{frame} %%Eine Folie
  \frametitle{Geometric Nontermination} 
  Necessary steps for the derivation of a GNA:
  \begin{enumerate}
  	\item derive the \stem
  	\item derive the \guardmatrix/\textit{Constants}
  	\item derive the \updatematrix/\textit{Constants}
  	\item compute the \iterationmatrix/\textit{Constants}
  	\item add the criteria of a GNA as assertions to an \solver
  	\item read of GNA (if exists)
  \end{enumerate}
\end{frame}

\subsection{Derivation: STEM}


\begin{frame}[fragile]
	\frametitle{Derivation: \stem}
	Consider \color{blue}two\color{black}\xspace different possibilities:
	\begin{tabular}{rl}
		\blue{constant stem}: & $f_x \rightarrow f_y(c_1,\dots,c_n) :|: TRUE$ \\
							  & $\Rightarrow$ read of values \\
	\end{tabular}
	\begin{example}
		\centering
		$f_1 \rightarrow f_2(10,-3)$
		$\Rightarrow$ \stem = $ (10, -3)^T$
	\end{example}

	\begin{tabular}{rl}
		\blue{variable stem}: & $f_x \rightarrow f_y(c_1+\sum_{i=1}^{n}a_{1,i}v_i, \dots, c_n+\sum_{i=1}^{n}a_{n,i}v_i) :|: $ \\
							  & $\bigwedge_{\text{guard }g} \sum_{i=1}^{n}g_{n,i}v_i \le c_m$ \\
							  & $\Rightarrow$ create assertions and derive a model \\
	\end{tabular}
	\begin{example}
		\centering
		$f_1 \rightarrow f_2(1 + 3v_1, -3) :|: v_1 > 2\text{ \&\& }8 < 3v_1 $ \newline
		$\Rightarrow$ model $m_1=\{v=3\}$ $\Rightarrow$\stem = $ (10, -3)^T$
	\end{example}
\end{frame}


\subsection{Derivation: Guard Matrix/Constants}
\begin{frame}
	\frametitle{Derivation: Guard Matrix/Constants}
	conditional term given by the \seg \newline
	\hspace*{1.5cm}$r = \&\&(g_1,( \&\& (\dots,(\&\&(g_{n-1},g_n) )\dots)))$
	\begin{algorithm}[H]
		\begin{algorithmic}[1]
			\Function{computeGuardSet}{Rule r}
			\State Stack $stack \gets r$
			\State Set $guards$
			\While{$!stack.isEmpty()$}
			\State $item \gets stack.pop$
			\If{item is of the form $\&\&(x_1,x_2)$}
			\State add $x_1$ and $x_2$ to $stack$
			\Else
			\State add $item$ to $guards$
			\EndIf				
			\EndWhile	
			\State \Return $guards$
			\EndFunction
		\end{algorithmic}
		\caption{derive set of guards}
	\end{algorithm}
\end{frame}	
	
\begin{frame}
	\begin{itemize}
		\item now we have $G=\{g \mid g \text{ is a guard}\}$
		\item \red{Problem}: $g$ could not be in the desired $\varphi \le c$ form.
		\item \red{Even worse}: $g$ could declare new variables using "$=$"
		\item \green{Solution}: bring every $g$ in the desired form, by: 
			\begin{tabular}{cll}
				1. & filter equalities   & by substituting "new" variables \\
				2. & normalizing ($\le$) & rewrite $<,>,\ge$ to $\le$ \\
				3. & normalizing ($c$)   & transfer only constant term to r.h.s.\\
			\end{tabular}
	\end{itemize}	
\end{frame}

\begin{frame} % filter eq
	\vspace*{-.25cm}
	\begin{algorithm}[H]
		\begin{algorithmic}[1]
			\Function{filterEqualities}{$G$}
			\State $V_{left} = \{v \mid $the left hand side of the rule contains $ v\}$
			\State $V_{right} = \{v \mid $the right hand side of the rule contains $ v\}$
			\State $V_{sub} = V_{right} - V_{left}$
			\State define substitution $\theta=\{\}$
			\While{$V_{sub} \neq \emptyset}$
			\State select $ s \in V_{sub}$
			\State select $g_s \in \{g \in G\mid g \text{ contains } "=" \}$
			\State remove $g_s$ from $G$
			\State rewrite $g_s$ to the form $s = \psi$
			\State $\theta=\theta\{s/\psi\}$
			\ForAll{$g\in G$}
			\State $g = \theta g$
			\EndFor	
			\State remove $s$ from $V_{sub}$
			\EndWhile
			\State \Return $G$
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
\end{frame}

\begin{frame} % bsp: filter eq.
	\begin{example}
		From the example \its we get using the decat. algorithm:\newline
		$\{v_1 + v_2 > 3\text{, } v_1 > 6 \text{, } 3 * v_1 > 20 \text{, } 5 + v_3 = 2 * v_2 \text{, } v_3 < -10\}$
		\begin{enumerate}
%			\setlength{\itemindent}{1cm}
			\item We compute $V_{left}=\{v_1, v_2\}$, $V_{right}=\{v_1,v_2,v_3\}$ so $V_{sub}=\{v_3\}$
			\item Begin with $\theta=\{\}$ 
			\item Since obviously $V_{sub} \neq \emptyset$  we select $s=v_3$ and select $g_s \Leftrightarrow 5+v_3=2*v_2$
			\item $g_s$ rewritten to the form $s=\psi$ then follows with $v_3=2*v_2-5$
			\item $\theta = \theta\{s/2*v_2-5\} = \{s/2*v_2-5\}$
			\item $G=\{v_1 + v_2 > 3$, $ v_1 > 6 $, $ 3 * v_1 > 20 $, $ 2*v_2-5 < -10\}$
			\item Since $V_{sub}=\emptyset$ return $G$
		\end{enumerate}
	\end{example}
\end{frame}

\begin{frame} % normal. <=
	\frametitle{normalization ($\le$)}
	rewrite a guard $g_i$ of the form $g_i \Leftrightarrow \psi + c_{\psi} \circ c$, where $\circ \in \{<,>,\le,\ge\}$ to the form $ \eta*\psi + \eta*c_{\psi} \le \eta*c-\tau$ depending on $\circ$.\newline
	\begin{figure}[H]
		\vspace*{-1cm}
		\centering
		\begin{tabular}{|l|r|l|l|}
			\hline
			$\circ$ 	& $\eta$ 	& $\tau$ 	&  $ \eta*\psi + \eta*c_{\psi} \le \eta*c-\tau$ \\ 
			\hline \hline
			$<$ 		& $1$ 		&  $1$ 		& $\psi + c_{\psi} \le c - 1$ \\ \hline
			$>$ 		& $-1$		&  1 		& $-\psi - c_{\psi} \le -c -1 $ \\ \hline
			$\le$ 		& $1$ 		&  0 		& $\psi + c_{\psi} \le c$ \\ \hline
			$\ge$ 		& $-1$ 		&  0 		& $-\psi - c_{\psi} \le -c$ \\ \hline
		\end{tabular}
	\end{figure}
	\footnotesize
	$\eta$ is the indicator of inverting the guard to convert $\ge$ ($>$) to $\le$ ($<$)\newline
	$\tau$ is the possible subtraction of 1 to receive the $\le$ instead of a $<$.
\end{frame}

\begin{frame} % normal. c
	\frametitle{normalization ($c$)}
	Subtract the term $\eta*c_\psi$ on both sides: \newline
	final form:  $\eta*\psi \le \underbrace{\eta*c -\tau -1*\eta*c_{\psi}}_{\text{constant term}}$
	
	\begin{variableblock}{Reminder: \its structure}{bg=orange!50!white,fg=black}{bg=orange, fg=white}
		Can derive constant factors very simple using a structure property :
		\begin{figure}[H]
			\centering
			\begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}]
			\node[objDia] (top) {
				\textbf{f1}: RPNFunctionSymbol
				\nodepart{second}arithmeticSymbol: $\le$
			};
			\node[rectangle, draw=black, rounded corners, text centered, anchor=north, below left = of top] (left) {
				$\eta*\psi$
			};
			\node[objDia, below right = of top] (right) {
				\textbf{c1}: RPNConstant
				\nodepart{second}value: $\eta*c -\tau -1*\eta*c_{\psi}$
			};
			
			\draw[thickarrow] (top.south)  -- ++(0,-0.5) -| (left.north) node [pos = 0.4, above, font=\footnotesize]{left};
			\draw[thickarrow] (top.south)  -- ++(0,-0.5) -| (right.north) node [pos = 0.4, above, font=\footnotesize]{right};
			\end{tikzpicture}
		\end{figure}
	\end{variableblock}
\end{frame}

\begin{frame} % bsp: norm
	\begin{example}
		Normalizing the guard $g \Leftrightarrow 3*v_1>20 \Leftrightarrow \underbrace{3*v_1}_{\psi}+\underbrace{0}_{c_\psi} > \underbrace{20}_{c}$ \vspace*{-1em}\newline
		
		Looking up the row for $\circ \Leftrightarrow >$: 
		\begin{tabular}{|l|r|l|l|}
			\hline
			$\circ$ 	& $\eta$ 	& $\tau$ 	&  $ \eta*\psi + \eta*c_{\psi} \le \eta*c-\tau$ \\ 
			\hline \hline
			\vdots 		& \vdots 	&  \vdots 		& \vdots \\ \hline
			$>$ 		& $-1$		&  1 		& $-\psi - c_{\psi} \le -c -1 $ \\ \hline
		\end{tabular} \newline
	
		Result with $\eta=-1$, $\tau = 1$ in: $-(3*v_1)-(0)\le-20-1 \Leftrightarrow -3*v_1 \le -21$
	\end{example}
\end{frame}

\begin{frame} % conclus
	\begin{itemize}
		\item now every guard has the form $\varphi \le c$
		\item deriving \guardconstants is very simple
		\item deriving \guardmatrix is read off the coefficients.
		\hspace*{1.5cm}(more detailed within the \updatematrix)
		\item[$\Rightarrow$] \updatematrix/\textit{Constants} derived \checkmark
	\end{itemize}
\end{frame}

\subsection{Derivation: Update Matrix/Constants}
\begin{frame}
	\frametitle{Derivation: Update Matrix/Constants}
	\begin{itemize}
		\item do \underline{not} contain any (in-)equalities
		\item follow the form: $c+\sum_{i=1}^{n}a_i v_i$ (\underline{not} $v_i a_i$)
		\item \red{Problem}: can still contain new variables from the guards
		\item[] \green{Solution}: apply substitutions to the updates
		\item \red{Problem}: constant term can occur anywhere
		\item[] \green{Solution}: perform recursive search under certainty of two aspects:
			\begin{enumerate}
				\item at most one constant term exists
				\item the constant term is \underline{not} multiplied
			\end{enumerate}
	\end{itemize}
\end{frame}

\begin{frame} % algo: coefficient deriv.
	\begin{algorithm}[H]
		\caption{Derivation of a coefficient}
		\begin{algorithmic}[1]
			\Function{getCoefficient}{$query$}
			\If{this == query}
			\State \Return $1$
			\ElsIf{this does \underline{not} contain query}
			\State \Return $0$
			\EndIf
			\State
			\If{this represents PLUS}
			\If{left side contains $query$}
			\State \Return getCoefficient$(query)$
			\Else
			\State \Return getCoefficient$(query)$
			\EndIf
			\EndIf
			\If{this represents TIMES}
			\If{this.right == query}
			\State \Return this.left.value
			\EndIf				
			\EndIf
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
\end{frame}

%\begin{frame}
%	code of constant derivation
%\end{frame}

\begin{frame}
	\begin{example}
		An example of coefficient derivation for query $v_1$:
		\begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}]
		\node (Plus) at (0,0) [objDia] {
			\textbf{f1}:RPNFunctionSymbol
			\nodepart{second}arithmeticSymbol: PLUS
		};
		\node (Times1) at (-4, -2 ) [objDia] {
			\textbf{f2}:RPNFunctionSymbol
			\nodepart{second}arithmeticSymbol: TIMES	
		};
		\node (cons1) at (-6, -4) [objDia] {
			\textbf{c1}:RPNConstant
			\nodepart{second}value: 3
		};
		\node (var1) at (-2, -4)[objDia] {
			\textbf{v1}:RPNVariable
			\nodepart{second}varName: $v_1$
		};
		\node (var2) at (4, -2) [objDia] {
			\textbf{v2}:RPNVariable
			\nodepart{second}varName: $v_2$
		};
		\draw[considered] (Plus.south)  -- ++(0,-0.4) -| (Times1.north) node [pos = 0.4, above, font=\footnotesize]{left};
		\draw[neglected] (Plus.south)  -- ++(0,-0.4) -| (var2.north) node [pos = 0.4, above, font=\footnotesize]{right};
		\draw[considered] (Times1.south)  -- ++(0,-0.5) -| (cons1.north) node [pos = 0.4, above, font=\footnotesize]{left};
		\draw[query] (Times1.south)  -- ++(0,-0.5) -| (var1.north) node [pos = 0.4, above, font=\footnotesize]{right};
		\end{tikzpicture}
	\end{example}
\end{frame}


\subsection{Derivation: Iteration Matrix/Constants}
\begin{frame} % iterationmatrix
	\frametitle{\updatematrix/\textit{Constants} \& \iterationmatrix/\textit{Constants}}
	\begin{itemize}
		\item derived a coefficient for every variable and constant per update
		\item[$\Rightarrow$] \updatematrix/\textit{Constants} \checkmark
		\item \iterationmatrix/\textit{Constants} given by: 
			\begin{figure}[H]
				\centering
				$A = \begin{pmatrix} G & \textbf{0} \\ M & -I \\ -M & I \end{pmatrix}$ and $b = \begin{pmatrix} g \\ -u \\ u \end{pmatrix}$
			\end{figure}
		 can be computed
		 \item[$\Rightarrow$] \iterationmatrix/\textit{Constants} \checkmark
	\end{itemize}
\end{frame}

\subsection{Derivation: SMT-Problem}
\begin{frame}
	\frametitle{SMT-Problem}
	\begin{itemize}
		\item given $A$ and $b$ use a \solver to dis-/prove existence of a GNA
		\item regarding the proof of the GNA:
		\item[]	\begin{definition}
					$\lambda_i$ is the $i$-th eigenvalue of $U$.
				\end{definition}
		\item \red{Problem}: $\mu_i*y_i$ is non-linear
		\item[] can approach this problem in 2 ways:
			\begin{enumerate}
				\item use \qfnia
				\item iterate over all $\mu$'s
			\end{enumerate}
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{variableblock}{Reminder: Domain Criteria}{bg=orange!50!white,fg=black}{bg=orange, fg=white}
		\begin{itemize}
			\setlength{\itemindent}{1cm}
			\item[(domain)] $x, y_1, \dots, y_k \in \mathbb{R}^n$, $\lambda_1, \dots \lambda_k, \mu_1, \dots \mu_{k-1} \ge 0$
		\end{itemize}
	\end{variableblock}
	\begin{itemize}
		\item[] $\Rightarrow$ adds no assertion
	\end{itemize}
	\begin{variableblock}{Reminder: Initiation Criteria}{bg=orange!50!white,fg=black}{bg=orange, fg=white}<2>
		\begin{itemize}
			\setlength{\itemindent}{1cm}
			\item[(init)] x represents the \startterm (\stem)
		\end{itemize}
	\end{variableblock}
	\begin{itemize}
		\item[]<2> $\Rightarrow$ adds no assertion
	\end{itemize}
	
\end{frame}

\begin{frame}
	\begin{variableblock}{Reminder: Point Criteria}{bg=orange!50!white,fg=black}{bg=orange, fg=white}
		\begin{itemize}
			\setlength{\itemindent}{1cm}
%			\item[(domain)] $x, y_1, \dots, y_k \in \mathbb{R}^n$, $\lambda_1, \dots \lambda_k, \mu_1, \dots \mu_{k-1} \ge 0$
%			\item[(init)] x represents the \startterm (\stem)
			\item[(point)] $A\begin{pmatrix} x \\ x + \sum_i y_i \end{pmatrix} \le b$
			%			\item[(ray)] $A\begin{pmatrix} y_i \\ \lambda_i y_i + \mu_{i-1} y_{i-1} \end{pmatrix} \le 0$ for all $1 \le i \le k$
		\end{itemize}
	\end{variableblock}
	\begin{itemize}
		\item $y_i$ unknown $\Rightarrow$ create $s_i=x_i+\sum_{j=1}^n y_{j,i}$
		\item<1> $A\begin{pmatrix} x \\ s \end{pmatrix} \le b$ \newline
	\end{itemize}
	$\Leftrightarrow \begin{pmatrix}
	& G 		& 			& 0 	 & \dots  & 0 \\
	a_{1,1}  & \dots 	& a_{1,n}	& -1 	 & \dots  & 0 \\
	\vdots   & \ddots 	& \vdots	& \vdots & \ddots & \vdots \\
	a_{n,1}  & \dots 	& a_{n,n}	& 0 	 & \dots  & -1 \\
	-a_{1,1} & \dots 	& -a_{1,n}	& 1 	 & \dots  & 0 \\
	\vdots   & \ddots 	& \vdots	& \vdots & \ddots & \vdots \\
	-a_{n,1} & \dots 	& -a_{n,n}	& 0 	 & \dots  & 1 \\
	\end{pmatrix} \begin{pmatrix} x1 \\ \vdots \\ x_n \\ s_1 \\ \vdots \\ s_n\end{pmatrix} \le \begin{pmatrix} g \\ -u_1 \\ \vdots\\ -u_n \\ u_1 \\ \vdots \\ u_n \end{pmatrix}$\\ %\newline
\end{frame}

\begin{frame}[fragile]
	\begin{itemize}
%		\item $y_i$ unknown $\Rightarrow$ create $s_i=x_i+\sum_{j=1}^n y_{j,i}$
		\vspace*{-1em} \item[] \hspace*{-1cm} 
			\begin{tikzpicture}
				\matrix [matrix of math nodes,left delimiter=(,right delimiter=)] (m)
				{
					a_{1,1}*x_1  & \dots 	& a_{1,n}*x_n	& -1*s_1 & \dots  & 0*s_n \\
					\vdots   	 & \ddots 	& \vdots		& \vdots & \ddots & \vdots \\
					a_{n,1}*x_1  & \dots 	& a_{n,n}*x_n	& 0*s_1	 & \dots  & -1*s_n \\
					-a_{1,1}*x_1 & \dots 	& -a_{1,n}*x_n	& 1*s_1	 & \dots  & 0*s_n \\
					\vdots   	 & \ddots 	& \vdots		& \vdots & \ddots & \vdots \\
					-a_{n,1}*x_1 & \dots 	& -a_{n,n}*x_n	& 0*s_1	 & \dots  & 1*s_n \\           
				};  
				\node[right = 0.25 cm of m] (le) {$\le$}; 
				\matrix [right = 0.25cm of le, matrix of math nodes,left delimiter=(,right delimiter=)] (c)
				{
					-u_1 \\ 
					\vdots\\ 
					-u_n \\ 
					u_1 \\ 
					\vdots \\ 
					u_n \\           
				};
				\draw[color=red, thick] (m-1-1.north west) -- (m-1-6.north east) -- (m-1-6.south east) -- (m-1-1.south west) -- (m-1-1.north west);	
				\draw[color=red, thick] (m-4-1.north west) -- (m-4-6.north east) -- (m-4-6.south east) -- (m-4-1.south west) -- (m-4-1.north west);
				\draw[color=red, thick] (c-1-1.north west) -- (c-1-1.north east) -- (c-1-1.south east) -- (c-1-1.south west) -- (c-1-1.north west);
				\draw[color=red, thick] (c-4-1.north west) -- (c-4-1.north east) -- (c-4-1.south east) -- (c-4-1.south west) -- (c-4-1.north west);
			\end{tikzpicture}
		\item[$\Rightarrow$] add guard assertion, $n$ assertions of equality 
		\item[] and addition assertion for every $s_i$
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{variableblock}{Reminder: Ray Criteria}{bg=orange!50!white,fg=black}{bg=orange, fg=white}
		\begin{itemize}
			\setlength{\itemindent}{1cm}
			\item[(ray)] $A\begin{pmatrix} y_i \\ \lambda_i y_i + \mu_{i-1} y_{i-1} \end{pmatrix} \le 0$ for all $1 \le i \le k$
		\end{itemize}
	\end{variableblock}
	\begin{itemize}
		\setlength{\itemindent}{1cm}
		\item[$i=1$:] $\Rightarrow \mu_{i-1}y_{i-1}=0 \Rightarrow $ $A\begin{pmatrix} y_1 \\ \lambda_1 y_1 \end{pmatrix} \le 0$
		\item[]	add assertion with $y_{1,j}$ $1\le j \le n$ as new variables
		\item[$i>1$:] with $\lambda_i$ as the $i$-th eigenvalue 
		\item[] add assertion with $y_{i,j}$ $1 \le j \le n$ and $\mu_i$ as new variables
		\item[]
		\item[] $\Rightarrow$ all necessary assertions stated \checkmark
		\item[] let \solver derive a GNA (if exists)
	\end{itemize}	
\end{frame}


\begin{frame}
	\begin{variableblock}{Reminder: Derived matrices and values}{bg=orange!50!white,fg=black}{bg=orange, fg=white}
		\begin{tabular}{llc}
			\multirow{2}{*}{$A=\begin{pmatrix}
				-1 		& -1 		&  0		& 0		 \\
				-1 		& 0 		&  0		& 0		 \\
				-3 		& 0 		&  0		& 0		 \\
				0 		& 2 		&  0		& 0		 \\
				3 		& 1 		&  -1		& 0		 \\
				0 		& 2 		&  0		& -1	 \\
				-3 		& -1 		&  1		& 0		 \\
				0 		& -2 		&  0		& 1	 	 \\
				\end{pmatrix}$}&\multirow{2}{*}{$ b=\begin{pmatrix}
				-4 \\ -7 \\ -21 \\ -6 \\ 0 \\ 5 \\ 0 \\ -5
				\end{pmatrix} $}& $\lambda_1 = 3,$ \\
			& &  $\lambda_2 = 2$\\
			& & $x=(10, -3)^T$ \\
			& & \\
			& & \\
			& & \\
			& & \\
			& & \\
		\end{tabular}
	\end{variableblock}
	\begin{example}[Assertions \rom{1}: Point Crit.]
		\begin{itemize}
			\item add guards. I.e.: $-10-(-3)\le-4$
			\item		  add sum rules. I.e.: $30-3-s_1=0$
			\item       add $s_1= y_{1,1}+y_{2,1}$ and $s_2=y_{1,2}+y_{2,2}$
		\end{itemize}
	\end{example}	
\end{frame}

\begin{frame}
	\begin{variableblock}{Reminder: Derived matrices and values}{bg=orange!50!white,fg=black}{bg=orange, fg=white}
		\begin{tabular}{llc}
			\multirow{2}{*}{$A=\begin{pmatrix}
				-1 		& -1 		&  0		& 0		 \\
				-1 		& 0 		&  0		& 0		 \\
				-3 		& 0 		&  0		& 0		 \\
				0 		& 2 		&  0		& 0		 \\
				3 		& 1 		&  -1		& 0		 \\
				0 		& 2 		&  0		& -1	 \\
				-3 		& -1 		&  1		& 0		 \\
				0 		& -2 		&  0		& 1	 	 \\
				\end{pmatrix}$}&\multirow{2}{*}{$ b=\begin{pmatrix}
				-4 \\ -7 \\ -21 \\ -6 \\ 0 \\ 5 \\ 0 \\ -5
				\end{pmatrix} $}& $\lambda_1 = 3,$ \\
			& &  $\lambda_2 = 2$\\
			& & $x=(10, -3)^T$ \\
			& & \\
			& & \\
			& & \\
			& & \\
			& & \\
		\end{tabular}
	\end{variableblock}
	\begin{example}[Assertions \rom{2}: Ray Crit.]
		\begin{itemize}
			\setlength{\itemindent}{0.25cm}
			\item[i=1:] add for instance $-y_{1,1}-y_{1,2}\le 4$, $3*y_{1,1}+y_{1,2}-3*y_{1,1}\le0$
			\item[i$>$1:] add for instance $-y_{2,1}-y_{2,2}\le 4$, 
			\item[] $3*y_{2,1}+y_{2,2}-1*(2*y_{2,1}+\mu*y_{1,1})\le0$
		\end{itemize}
	\end{example}
\end{frame}




\section{Verification of a GNA}
\frame{\tableofcontents[currentsection]}
\begin{frame}
	\frametitle{\color{white}Verification of a GNA}
	\begin{itemize}
		\item received a GNA form the \solver
		\item want to verify the correctness of the \solver's model
		\item[$\Rightarrow$] recalculating of a GNA with the matrices and given values
	\end{itemize}
	\begin{example}[Validating a GNA \rom{1}]
		The \solver gave us: $y_1=\begin{pmatrix} 9 \\ 0 \end{pmatrix}$, $y_2=\begin{pmatrix} 8 \\ -8 \end{pmatrix}$, $\mu_1=0$\newline
		\begin{itemize}
			\setlength{\itemindent}{1.5cm}
			\item[(domain)]<1-> obviously true \checkmark
			\item[(init)]<2-> checked against the \stem \checkmark
			\item[(point)]<3->  $A\begin{pmatrix} 10 \\ -3 \\ 10+9+8 \\ -3 + 0 + (-8) \end{pmatrix} \le b \Leftrightarrow A\begin{pmatrix} 10 \\ -3 \\ 27 \\ -11 \end{pmatrix} \le b$ \checkmark
		\end{itemize}
	\end{example}
\end{frame}

\begin{frame}
	\begin{example}[Validating a GNA \rom{2}]
		The \solver gave us: $y_1=\begin{pmatrix} 9 \\ 0 \end{pmatrix}$, $y_2=\begin{pmatrix} 8 \\ -8 \end{pmatrix}$, $\mu_1=0$\newline
		\begin{itemize}
			\setlength{\itemindent}{0.5cm}
			\item[(ray)]
			\item[$i=1$:]<1->  $A\begin{pmatrix} 9 \\ 0 \\ 3*9 \\ 3*0 \end{pmatrix} \le 0 \Leftrightarrow A\begin{pmatrix} 9 \\ 0 \\ 27 \\ 0 \end{pmatrix} \le 0$ \checkmark
			\item[$i>1$:]<2> $A\begin{pmatrix} 8 \\ -8 \\ 2*8+0*9 \\ 2*(-8)+0*0 \end{pmatrix} \le 0 \Leftrightarrow A\begin{pmatrix} 8 \\ -8 \\ 16 \\ -16 \end{pmatrix} \le 0$ \checkmark
		\end{itemize}
		$\Rightarrow$ the derived GNA is applicable $\Rightarrow$ nontermination is proven
	\end{example}
\end{frame}






